<application>
  <component name="AppStorage">
    <histories>
      <item value="@SneakyThrow will avoid javac's insistence that you either catch or throw onward any checked exceptions that statements in your method body declare they generate.&#10;@SneakyThrow does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed checked exception types. The JVM does not check for the consistency of the checked exception system; javac does, and this annotation lets you opt out of its mechanism.&#10;Complete documentation is found at the project lombok features page for @SneakyThrows .&#10;Example:&#10;   @SneakyThrows(UnsupportedEncodingException.class)&#10;   public String utf8ToString(byte[] bytes) {&#10;       return new String(bytes, &quot;UTF-8&quot;);&#10;   }&#10;   &#10;Becomes:&#10;   public String utf8ToString(byte[] bytes) {&#10;       try {&#10;           return new String(bytes, &quot;UTF-8&quot;);&#10;       } catch (UnsupportedEncodingException uniqueName) {&#10;           throw useMagicTrickeryToHideThisFromTheCompiler(uniqueName);&#10;            This trickery involves a bytecode transformer run automatically during the final stages of compilation;&#10;            there is no runtime dependency on lombok.&#10;       }&#10;   " />
      <item value="Inclusion mechanism similar to PROPERTY with respect to deserialization; but one that is produced by a &quot;regular&quot; accessible property during serialization. This means that TypeSerializer will do nothing, and expects a property with defined name to be output using some other mechanism (like default POJO property serialization, or custom serializer).&#10;Note that this behavior is quite similar to that of using JsonTypeId annotation; except that here TypeSerializer is basically suppressed; whereas with JsonTypeId, output of regular property is suppressed. This mostly matters with respect to output order; this choice is the only way to ensure specific placement of type id during serialization.&#10;自:&#10;2.3.0 but databind only since 2.5.0." />
      <item value="Inclusion mechanism that wraps typed JSON value (POJO serialized as JSON) in a 2-element JSON array: first element is the serialized type identifier, and second element the serialized POJO as JSON Object." />
      <item value="Inclusion mechanism that wraps typed JSON value (POJO serialized as JSON) in a JSON Object that has a single entry, where field name is serialized type identifier, and value is the actual JSON value.&#10;Note: can only be used if type information can be serialized as String. This is true for standard type metadata types, but not necessarily for custom types." />
      <item value="Inclusion mechanism that uses a single configurable property, included along with actual data (POJO properties) as a separate meta-property.&#10;Default choice for inclusion." />
      <item value="Annotation used for configuring details of if and how type information is used with JSON serialization and deserialization, to preserve information about actual class of Object instances. This is necessarily for polymorphic types, and may also be needed to link abstract declared types and matching concrete implementation.&#10;Some examples of typical annotations:&#10;     Include Java class name (&quot;com.myempl.ImplClass&quot;) as JSON property &quot;class&quot;&#10;    @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property=&quot;class&quot;)&#10;    &#10;     Include logical type name (defined in impl classes) as wrapper; 2 annotations&#10;    @JsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT)&#10;    @JsonSubTypes({com.myemp.Impl1.class, com.myempl.Impl2.class})&#10;  &#10;Alternatively you can also define fully customized type handling by using @JsonTypeResolver annotation (from databind package).&#10;This annotation can be used both for types (classes) and properties. If both exist, annotation on property has precedence, as it is considered more specific.&#10;When used for properties (fields, methods), this annotation applies to values: so when applied to structure types (like java.util.Collection, java.util.Map, arrays), will apply to contained values, not the container; for non-structured types there is no difference. This is identical to how JAXB handles type information annotations; and is chosen since it is the dominant use case. There is no per-property way to force type information to be included for type of container (structured type); for container types one has to use annotation for type declaration.&#10;Note on visibility of type identifier: by default, deserialization (use during reading of JSON) of type identifier is completely handled by Jackson, and is not passed to deserializers. However, if so desired, it is possible to define property visible = true in which case property will be passed as-is to deserializers (and set via setter or field) on deserialization.&#10;On serialization side, Jackson will generate type id by itself, except if there is a property with name that matches property(), in which case value of that property is used instead.&#10;NOTE: use of type id of &quot;class name&quot; with very general base type (such as Object or java.io.Serializable) can potentially open up security holes if deserializing content generated by untrusted sources. If content can not be trusted, it is necessary to either use &quot;type name&quot; as type id, or to limit possible types using other means." />
      <item value="DEDUCTION" />
      <item value="Means that no serialized typing-property is used. Types are deduced based on the fields available. Deduction is limited to the names of fields (not their values or, consequently, any nested descendants). Exceptions will be thrown if not enough unique information is present to select a single subtype. If deduction is being used annotation properties visible, property and include are ignored." />
      <item value="This means that no explicit type metadata is included, and typing is purely done using contextual information possibly augmented with other annotations." />
      <item value="Definition of different type identifiers that can be included in JSON during serialization, and used for deserialization." />
      <item value="Comparable" />
      <item value="comparable" />
      <item value="delta" />
      <item value="Round Robin Load Balancer" />
      <item value="Noop Service Instance List Supplier" />
      <item value="Stream Cluster" />
      <item value="truncated" />
      <item value="Complex Transformer" />
      <item value="on Miss Default Value" />
      <item value="字典" />
      <item value="Complex Transformer Proxy" />
      <item value="  Like the assembly:attached goal, assemble an application bundle or&#10;  distribution using an assembly descriptor from the command line. This goal&#10;  will force Maven to build all included POMs up to the package phase BEFORE the&#10;  assembly is processed. This goal differs from assembly:assembly in that it&#10;  ignores the &lt;formats&gt; section of the assembly descriptor, and forces the&#10;  assembly to be created as a directory in the project's build-output directory&#10;  (usually .target).&#10;  This goal is also functionally equivalent to using the assembly:assembly goal&#10;  in conjunction with the dir assembly format.&#10;  NOTE: This goal should ONLY be run from the command line, and if building a&#10;  multimodule project it should be used from the root POM. Use the&#10;  assembly:directory-single goal for binding your assembly to the lifecycle." />
      <item value="Assemble an application bundle or distribution using an assembly descriptor&#10;  from the command line. This goal will force Maven to build all included POMs&#10;  up to the package phase BEFORE the assembly is processed.&#10;  NOTE: This goal should ONLY be run from the command line, and if building a&#10;  multimodule project it should be used from the root POM. Use the&#10;  assembly:single goal for binding your assembly to the lifecycle." />
      <item value="assembly" />
      <item value="asse" />
      <item value="firewall-cmd --add-port=123/tcp --permanent" />
      <item value="asset Manage CK Info" />
      <item value="  Simple stop watch, allowing for timing of a number of tasks, exposing total&#10;  running time and running time for each named task.&#10; &#10;  &lt;p&gt;Conceals use of {@link SystemnanoTime()}, improving the readability of&#10;  application code and reducing the likelihood of calculation errors.&#10; &#10;  &lt;p&gt;Note that this object is not designed to be thread-safe and does not use&#10;  synchronization.&#10; &#10;  &lt;p&gt;This class is normally used to verify performance during proof-of-concept&#10;  work and in development, rather than as part of production applications.&#10; &#10;  &lt;p&gt;As of Spring Framework 5.2, running time is tracked and reported in" />
      <item value="escalation" />
      <item value="scenario Analysis Report" />
      <item value="demand" />
      <item value="      Returns the trigonometric cosine of an angle. Special cases:&#10;      &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the&#10;      result is NaN.&lt;ul&gt;&#10;     &#10;      &lt;p&gt;The computed result must be within 1 ulp of the exact result.&#10;      Results must be semi-monotonic." />
      <item value="  Instances of this class support both reading and writing to a&#10;  random access file. A random access file behaves like a large&#10;  array of bytes stored in the file system. There is a kind of cursor,&#10;  or index into the implied array, called the &lt;em&gt;file pointer&lt;em&gt;;&#10;  input operations read bytes starting at the file pointer and advance&#10;  the file pointer past the bytes read. If the random access file is&#10;  created in readwrite mode, then output operations are also available;&#10;  output operations write bytes starting at the file pointer and advance&#10;  the file pointer past the bytes written. Output operations that write&#10;  past the current end of the implied array cause the array to be&#10;  extended. The file pointer can be read by the&#10;  {@code getFilePointer} method and set by the {@code seek}&#10;  method.&#10;  &lt;p&gt;&#10;  It is generally true of all the reading routines in this class that&#10;  if end-of-file is reached before the desired number of bytes has been&#10;  read, an {@code EOFException} (which is a kind of&#10;  {@code IOException}) is thrown. If any byte cannot be read for&#10;  any reason other than end-of-file, an {@code IOException} other&#10;  than {@code EOFException} is thrown. In particular, an&#10;  {@code IOException} may be thrown if the stream has been closed." />
      <item value="Reads in &lt;b&gt;little endian&lt;b&gt; order, as required by the zipfile&#10;  format." />
      <item value="max Fill Read Capacity" />
      <item value="      Waits at most {@code millis} milliseconds for this thread to&#10;      die. A timeout of {@code 0} means to wait forever.&#10;     &#10;      &lt;p&gt; This implementation uses a loop of {@code this.wait} calls&#10;      conditioned on {@code this.isAlive}. As a thread terminates the&#10;      {@code this.notifyAll} method is invoked. It is recommended that&#10;      applications not use {@code wait}, {@code notify}, or&#10;      {@code notifyAll} on {@code Thread} instances." />
      <item value="Method called to assign value serializer for property" />
      <item value=" * Abstract class that defines API for objects that can be registered (for {@link BeanSerializerFactory}&#10; * to participate in constructing {@link BeanSerializer} instances.&#10; * This is typically done by modules that want alter some aspects of serialization&#10; * process; and is preferable to sub-classing of {@link BeanSerializerFactory}.&#10; *&lt;p&gt;&#10; * Sequence in which callback methods are called is as follows:&#10; * &lt;ol&gt;&#10; *  &lt;li&gt;After factory has collected tentative set of properties (instances of&#10; *     &lt;code&gt;BeanPropertyWriter&lt;/code&gt;) is sent for modification via&#10; *     {@link #changeProperties}. Changes can include removal, addition and&#10; *     replacement of suggested properties.&#10; *  &lt;li&gt;Resulting set of properties are ordered (sorted) by factory, as per&#10; *     configuration, and then {@link #orderProperties} is called to allow&#10; *     modifiers to alter ordering.&#10; *  &lt;li&gt;After all bean properties and related information is accumulated,&#10; *     {@link #updateBuilder} is called with builder, to allow builder state&#10; *     to be modified (including possibly replacing builder itself if necessary)&#10; *  &lt;li&gt;Once all bean information has been determined,&#10; *     factory creates default {@link BeanSerializer} instance and passes&#10; *     it to modifiers using {@link #modifySerializer}, for possible&#10; *     modification or replacement (by any {@link com.fasterxml.jackson.databind.JsonSerializer} instance)&#10; * &lt;/ol&gt;&#10; *&lt;p&gt;&#10; * Default method implementations are &quot;no-op&quot;s, meaning that methods are implemented&#10; * but have no effect." />
      <item value="Intrinsic Candidate" />
      <item value="is Assignable From" />
      <item value="  * Determines if the class or interface represented by this&#10;     * {@code Class} object is either the same as, or is a superclass or&#10;     * superinterface of, the class or interface represented by the specified&#10;     * {@code Class} parameter. It returns {@code true} if so;&#10;     * otherwise it returns {@code false}. If this {@code Class}&#10;     * object represents a primitive type, this method returns&#10;     * {@code true} if the specified {@code Class} parameter is&#10;     * exactly this {@code Class} object; otherwise it returns&#10;     * {@code false}.&#10;     *&#10;     * &lt;p&gt; Specifically, this method tests whether the type represented by the&#10;     * specified {@code Class} parameter can be converted to the type&#10;     * represented by this {@code Class} object via an identity conversion&#10;     * or via a widening reference conversion. See &lt;cite&gt;The Java Language&#10;     * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},&#10;     * for details." />
      <item value="structured" />
      <item value="compared" />
      <item value=" * Vanilla {@link com.fasterxml.jackson.databind.Module} implementation that allows registration&#10; * of serializers and deserializers, bean serializer&#10; * and deserializer modifiers, registration of subtypes and mix-ins&#10; * as well as some other commonly&#10; * needed aspects (addition of custom {@link AbstractTypeResolver}s,&#10; * {@link com.fasterxml.jackson.databind.deser.ValueInstantiator}s).&#10; *&lt;p&gt;&#10; * NOTE: although it is not expected that sub-types should need to&#10; * override {@link #setupModule(SetupContext)} method, if they choose&#10; * to do so they MUST call {@code super.setupModule(context);}&#10; * to ensure that registration works as expected.&#10; *&lt;p&gt;&#10; * WARNING: when registering {@link JsonSerializer}s and {@link JsonDeserializer}s,&#10; * only type erased {@code Class} is compared: this means that usually you should&#10; * NOT use this implementation for registering structured types such as&#10; * {@link java.util.Collection}s or {@link java.util.Map}s: this because parametric&#10; * type information will not be considered and you may end up having &quot;wrong&quot; handler&#10; * for your type.&#10; * What you need to do, instead, is to implement {@link com.fasterxml.jackson.databind.deser.Deserializers} &#10; * and/or {@link com.fasterxml.jackson.databind.ser.Serializers} callbacks to match full type&#10; * signatures (with {@link JavaType})." />
      <item value="create Contextual" />
      <item value=" * Add-on interface that {@link JsonSerializer}s can implement to get a callback&#10; * that can be used to create contextual instances of serializer to use for&#10; * handling properties of supported type. This can be useful&#10; * for serializers that can be configured by annotations, or should otherwise&#10; * have differing behavior depending on what kind of property is being serialized.&#10; *&lt;p&gt;&#10; * Note that in cases where serializer needs both contextualization and&#10; * resolution -- that is, implements both this interface and {@link ResolvableSerializer}&#10; * -- resolution via {@link ResolvableSerializer} occurs first, and contextual&#10; * resolution (via this interface) later on." />
      <item value="     * Method called to see if a different (or differently configured) serializer&#10;     * is needed to serialize values of specified property.&#10;     * Note that instance that this method is called on is typically shared one and&#10;     * as a result method should &lt;b&gt;NOT&lt;/b&gt; modify this instance but rather construct&#10;     * and return a new instance. This instance should only be returned as-is, in case&#10;     * it is already suitable for use.&#10;     * &#10;     * @param prov Serializer provider to use for accessing config, other serializers&#10;     * @param property Method or field that represents the property&#10;     *   (and is used to access value to serialize).&#10;     *   Should be available; but there may be cases where caller cannot provide it and&#10;     *   null is passed instead (in which case impls usually pass 'this' serializer as is)&#10;     * &#10;     * @return Serializer to use for serializing values of specified property;&#10;     *   may be this instance or a new instance." />
      <item value="Desensitize" />
      <item value="Phone Desensitize" />
      <item value="desensitization" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="671" />
        <entry key="ENGLISH" value="673" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662097847073" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>