<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="2703" />
    <option name="newTranslationDialogY" value="454" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Column Type Convertor" />
      <item value="is Exist Updateable" />
      <item value="is Exist Configable" />
      <item value=" maximum number of fractional digits accepted for this number" />
      <item value="Digits" />
      <item value="negative" />
      <item value="statistical Size" />
      <item value="Mutation Plan" />
      <item value="combine" />
      <item value="side-effect" />
      <item value="On first setup, you may need to run ` mvn install -DskipTests`&#10;to install the local jars. This is a side-effect of multi-module maven projects" />
      <item value=" The most common stream of tokens where every token is buffered up&#10;   and tokens are filtered for a certain channel (the parser will only&#10;   see these tokens).&#10; &#10;   Even though it buffers all of the tokens, this token stream pulls tokens&#10;   from the tokens source on demand. In other words, until you ask for a&#10;   token using consume(), LT(), etc. the stream does not pull from the lexer.&#10; &#10;   The only difference between this stream and BufferedTokenStream superclass&#10;   is that this stream knows how to ignore off channel tokens. There may be&#10;   a performance advantage to using the superclass if you don't pass&#10;   whitespace and comments etc. to the parser on a hidden channel (i.e.,&#10;   you set channel instead of calling skip() in lexer rules.)" />
      <item value="coprocessor" />
      <item value=" Starts up a self-contained HBase cluster with Phoenix installed to allow simple local&#10;  testing of Phoenix." />
      <item value="  Test rule that prevents System.exit  JVM exit to error out the test runner, which manages&#10;  JVM and providing test output files, and instead throw valid Exception to handle JVM exit&#10;  gracefully" />
      <item value="  Annotates static fields that reference rules or methods that return them. A field must be public,&#10;  static, and a subtype of {@link org.junit.rules.TestRule}.  A method must be public static, and return&#10;  a subtype of {@link org.junit.rules.TestRule}.&#10;  &lt;p&gt;&#10;  The {@link org.junit.runners.model.Statement} passed&#10;  to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods,&#10;  then the entire body of the test class (all contained methods, if it is&#10;  a standard JUnit test class, or all contained classes, if it is a&#10;  {@link org.junit.runners.Suite}), and finally any {@link AfterClass} methods.&#10;  &lt;p&gt;&#10;  The statement passed to the {@link org.junit.rules.TestRule} will never throw an exception,&#10;  and throwing an exception from the {@link org.junit.rules.TestRule} will result in undefined&#10;  behavior.  This means that some {@link org.junit.rules.TestRule}s, such as" />
      <item value="  For pre-0.94.9 instances, this class tests correctly deserializing WALEdits wo compression. Post&#10;  0.94.9 we can support a custom  {@link WALCellCodec} which handles readingwriting the compressed&#10;  edits.&#10;  &lt;p&gt;&#10;  Most of the underlying work (creatingsplitting the WAL, etc) is from&#10;  org.apache.hadoop.hhbase.regionserver.wal.TestWALReplay, copied here for completeness and ease of&#10;  use.&#10;  &lt;p&gt;&#10;  This test should only have a single test - otherwise we will startstop the minicluster multiple&#10;  times, which is probably not what you want to do (mostly because its so much effort)." />
      <item value="Immutable Map" />
      <item value="Enumerable Property Source" />
      <item value="Composite Property Source" />
      <item value="  Composite {@link PropertySource} implementation that iterates over a set of&#10;  {@link PropertySource} instances. Necessary in cases where multiple property sources&#10;  share the same name, e.g. when multiple values are supplied to {@code @PropertySource}.&#10; &#10;  &lt;p&gt;As of Spring 4.1.2, this class extends {@link EnumerablePropertySource} instead&#10;  of plain {@link PropertySource}, exposing {@link getPropertyNames()} based on the&#10;  accumulated property names from all contained sources (as far as possible)." />
      <item value="  {@link BeanFactoryPostProcessor} used for bootstrapping processing of&#10;  {@link Configuration @Configuration} classes.&#10; &#10;  &lt;p&gt;Registered by default when using {@code &lt;context:annotation-config&gt;} or&#10;  {@code &lt;context:component-scan&gt;}. Otherwise, may be declared manually as&#10;  with any other {@link BeanFactoryPostProcessor}.&#10; &#10;  &lt;p&gt;This post processor is priority-ordered as it is important that any&#10;  {@link Bean @Bean} methods declared in {@code @Configuration} classes have&#10;  their corresponding bean definitions registered before any other&#10;  {@code BeanFactoryPostProcessor} executes." />
      <item value="elapsed" />
      <item value="combination" />
      <item value="  {@link org.springframework.context.MessageSource} implementation that&#10;  accesses resource bundles using specified basenames. This class relies&#10;  on the underlying JDK's {@link java.util.ResourceBundle} implementation,&#10;  in combination with the JDK's standard message parsing provided by&#10;  {@link java.text.MessageFormat}.&#10; &#10;  &lt;p&gt;This MessageSource caches both the accessed ResourceBundle instances and&#10;  the generated MessageFormats for each message. It also implements rendering of&#10;  no-arg messages without MessageFormat, as supported by the AbstractMessageSource&#10;  base class. The caching provided by this MessageSource is significantly faster&#10;  than the built-in caching of the {@code java.util.ResourceBundle} class.&#10; &#10;  &lt;p&gt;The basenames follow {@link java.util.ResourceBundle} conventions: essentially,&#10;  a fully-qualified classpath location. If it doesn't contain a package qualifier&#10;  (such as {@code org.mypackage}), it will be resolved from the classpath root.&#10;  Note that the JDK's standard ResourceBundle treats dots as package separators:&#10;  This means that &quot;test.theme&quot; is effectively equivalent to &quot;testtheme&quot;.&#10; &#10;  &lt;p&gt;On the classpath, bundle resources will be read with the locally configured&#10;  {@link setDefaultEncoding encoding}: by default, ISO-8859-1; consider switching&#10;  this to UTF-8, or to {@code null} for the platform default encoding. On the JDK 9+&#10;  module path where locally provided {@code ResourceBundle.Control} handles are not&#10;  supported, this MessageSource always falls back to {@link ResourceBundlegetBundle}&#10;  retrieval with the platform default encoding: UTF-8 with a ISO-8859-1 fallback on&#10;  JDK 9+ (configurable through the &quot;java.util.PropertyResourceBundle.encoding&quot; system&#10;  property). Note that {@link loadBundle(Reader)}{@link loadBundle(InputStream)}&#10;  won't be called in this case either, effectively ignoring overrides in subclasses.&#10;  Consider implementing a JDK 9 {@code java.util.spi.ResourceBundleProvider} instead." />
      <item value="Resource Bundle" />
      <item value="  Empty {@link MessageSource} that delegates all calls to the parent MessageSource.&#10;  If no parent is available, it simply won't resolve any message.&#10; &#10;  &lt;p&gt;Used as placeholder by AbstractApplicationContext, if the context doesn't&#10;  define its own MessageSource. Not intended for direct use in applications." />
      <item value="Delegating Message Source" />
      <item value="&#9;  Try to resolve the message using all the attributes contained within the&#10;&#9;  {@code MessageSourceResolvable} argument that was passed in.&#10;&#9;  &lt;p&gt;NOTE: We must throw a {@code NoSuchMessageException} on this method&#10;&#9;  since at the time of calling this method we aren't able to determine if the&#10;&#9;  {@code defaultMessage} property of the resolvable is {@code null} or not.&#10;&#9;  @param resolvable the value object storing attributes required to resolve a message&#10;&#9;  (may include a default message)&#10;&#9;  @param locale the locale in which to do the lookup&#10;&#9;  @return the resolved message (never {@code null} since even a&#10;&#9;  {@code MessageSourceResolvable}-provided default message needs to be non-null)&#10;&#9;  @throws NoSuchMessageException if no corresponding message was found&#10;&#9;  (and no default message was provided by the {@code MessageSourceResolvable})" />
      <item value="&#9;  Try to resolve the message. Return default message if no message was found.&#10;&#9;  @param code the message code to look up, e.g. 'calculator.noRateSet'.&#10;&#9;  MessageSource users are encouraged to base message names on qualified class&#10;&#9;  or package names, avoiding potential conflicts and ensuring maximum clarity.&#10;&#9;  @param args an array of arguments that will be filled in for params within&#10;&#9;  the message (params look like &quot;{0}&quot;, &quot;{1,date}&quot;, &quot;{2,time}&quot; within a message),&#10;&#9;  or {@code null} if none&#10;&#9;  @param defaultMessage a default message to return if the lookup fails&#10;&#9;  @param locale the locale in which to do the lookup&#10;&#9;  @return the resolved message if the lookup was successful, otherwise&#10;&#9;  the default message passed as a parameter (which may be {@code null})" />
      <item value="  &lt;p&gt;Spring provides two out-of-the-box implementations for production:&#10;  &lt;ul&gt;&#10;  &lt;li&gt;{@link org.springframework.context.support.ResourceBundleMessageSource}: built&#10;  on top of the standard {@link java.util.ResourceBundle}, sharing its limitations.&#10;  &lt;li&gt;{@link org.springframework.context.support.ReloadableResourceBundleMessageSource}:&#10;  highly configurable, in particular with respect to reloading message definitions.&#10;  &lt;ul&gt;" />
      <item value="  Strategy interface for resolving messages, with support for the parameterization&#10;  and internationalization of such messages." />
      <item value="&#9;  Used to dereference a {@link FactoryBean} instance and distinguish it from&#10;&#9;  beans &lt;i&gt;created&lt;i&gt; by the FactoryBean. For example, if the bean named&#10;&#9;  {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject}&#10;&#9;  will return the factory, not the instance returned by the factory." />
      <item value="&#9;  Replace the property source with the given name with the given property source object.&#10;&#9;  @param name the name of the property source to find and replace&#10;&#9;  @param propertySource the replacement property source&#10;&#9;  @throws IllegalArgumentException if no property source with the given name is present" />
      <item value="characteristics" />
      <item value="      Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.htmlbinding&quot;&gt;late-binding&lt;a&gt;&lt;em&gt;&#10;      and &lt;em&gt;fail-fast&lt;em&gt; {@link Spliterator} over the elements in this&#10;      list.&#10;     &#10;      &lt;p&gt;The {@code Spliterator} reports {@link SpliteratorSIZED},&#10;      {@link SpliteratorSUBSIZED}, and {@link SpliteratorORDERED}.&#10;      Overriding implementations should document the reporting of additional&#10;      characteristic values." />
      <item value="spliter" />
      <item value="spliterator" />
      <item value="Spliterator" />
      <item value="      The default implementation should usually be overridden.  The&#10;      spliterator returned by the default implementation has poor splitting&#10;      capabilities, is unsized, and does not report any spliterator&#10;      characteristics. Implementing classes can nearly always provide a&#10;      better implementation." />
      <item value="Mutable Property Sources" />
      <item value="  &lt;h3&gt;Registration&lt;h3&gt;&#10;  &lt;p&gt;An {@code ApplicationContext} auto-detects {@code BeanFactoryPostProcessor}&#10;  beans in its bean definitions and applies them before any other beans get created.&#10;  A {@code BeanFactoryPostProcessor} may also be registered programmatically&#10;  with a {@code ConfigurableApplicationContext}." />
      <item value="  &lt;p&gt;A {@code BeanFactoryPostProcessor} may interact with and modify bean&#10;  definitions, but never bean instances. Doing so may cause premature bean&#10;  instantiation, violating the container and causing unintended side-effects.&#10;  If bean instance interaction is required, consider implementing&#10;  {@link BeanPostProcessor} instead.&#10; " />
      <item value="  &lt;p&gt;Useful for custom config files targeted at system administrators that&#10;  override bean properties configured in the application context. See&#10;  {@link PropertyResourceConfigurer} and its concrete implementations for&#10;  out-of-the-box solutions that address such configuration needs.&#10; " />
      <item value="  Factory hook that allows for custom modification of an application context's&#10;  bean definitions, adapting the bean property values of the context's underlying&#10;  bean factory." />
      <item value="&#9;  Resolve {...} placeholders in the given text, replacing them with corresponding&#10;&#9;  property values as resolved by {@link getProperty}. Unresolvable placeholders with&#10;&#9;  no default value are ignored and passed through unchanged.&#10;&#9;  @param text the String to resolve&#10;&#9;  @return the resolved String (never {@code null})&#10;&#9;  @throws IllegalArgumentException if given text is {@code null}" />
      <item value="synthetic" />
      <item value="Flushable" />
      <item value="  An interpreter for printf-style format strings.  This class provides support&#10;  for layout justification and alignment, common formats for numeric, string,&#10;  and datetime data, and locale-specific output.  Common Java types such as&#10;  {@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}&#10;  are supported.  Limited formatting customization for arbitrary user types is&#10;  provided through the {@link Formattable} interface." />
      <item value="tagging" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1667627456170" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>