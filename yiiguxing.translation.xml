<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="590" />
    <option name="newTranslationDialogX" value="2783" />
    <option name="newTranslationDialogY" value="225" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="indicators" />
      <item value="event period" />
      <item value="  Marker annotation that indicates that the logical property that&#10;  the accessor (field, gettersetter method or Creator parameter&#10;  [of {@link JsonCreator}-annotated constructor or factory method])&#10;  is to be ignored by introspection-based&#10;  serialization and deserialization functionality.&#10; &lt;p&gt;&#10;  Annotation only needs to be added to one of the accessors (often&#10;  getter method, but may be setter, field or creator parameter),&#10;  if the complete removal of the property is desired.&#10;  However: if only particular accessor is to be ignored (for example,&#10;  when ignoring one of potentially conflicting setter methods),&#10;  this can be done by annotating other not-to-be-ignored accessors&#10;  with {@link JsonProperty} (or its equivalents). This is considered&#10;  so-called &quot;split property&quot; case and allows definitions of&#10;  &quot;read-only&quot; (read from input into POJO) and &quot;write-only&quot; (write&#10;  in output but ignore on output)&#10; &lt;br&gt;&#10;  NOTE! As Jackson 2.6, there is a new and improved way to define&#10;  `read-only` and `write-only` properties, using&#10;  {@link JsonPropertyaccess()} annotation: this is recommended over&#10;  use of separate &lt;code&gt;JsonIgnore&lt;code&gt; and {@link JsonProperty}&#10;  annotations.&#10; &lt;p&gt;&#10;  For example, a &quot;getter&quot; method that would otherwise denote&#10;  a property (like, say, &quot;getValue&quot; to suggest property &quot;value&quot;)&#10;  to serialize, would be ignored and no such property would&#10;  be output unless another annotation defines alternative method to use.&#10; &lt;p&gt;&#10;  When ignoring the whole property, the default behavior if encountering&#10;  such property in input is to ignore it without exception; but if there&#10;  is a {@link JsonAnySetter} it will be called instead. Either way,&#10;  no exception will be thrown.&#10; &lt;p&gt;&#10;  Annotation is usually used just a like a marker annotation, that&#10;  is, without explicitly defining 'value' argument (which defaults&#10;  to &lt;code&gt;true&lt;code&gt;): but argument can be explicitly defined.&#10;  This can be done to override an existing `JsonIgnore` by explicitly&#10;  defining one with 'false' argument: either in a sub-class, or by&#10;  using &quot;mix-in annotations&quot;." />
      <item value="A string composed of this string repeated&#10;               {@code count} times or the empty string if this&#10;               string is empty or count is zero" />
      <item value="      Returns a string whose value is the concatenation of this&#10;      string repeated {@code count} times.&#10;      &lt;p&gt;&#10;      If this string is empty or count is zero then the empty&#10;      string is returned." />
      <item value="DELAY MICROSECOND" />
      <item value="DELAY MILLISECOND" />
      <item value="title Suffer" />
      <item value="dest Data Unit" />
      <item value="flip" />
      <item value="mulit Ids" />
      <item value="Mulit" />
      <item value="get Mulit Dataset Vo" />
      <item value="Muli" />
      <item value="      Returns an {@code UnmodifiableList} of the CPU's physical processors. The&#10;      list will be sorted in order of increasing core ID.&#10;     &#10;      @return An {@code UnmodifiabeList} of physical processors." />
      <item value="the number of logical processors, which corresponds to the number&#10;                 of lines to read from the file." />
      <item value="caveats" />
      <item value="caveate" />
      <item value="cave" />
      <item value="interchangeable" />
      <item value="interchange" />
      <item value="inter" />
      <item value="counterpart" />
      <item value="counterparts" />
      <item value="c" />
      <item value="several" />
      <item value="se" />
      <item value="see" />
      <item value="particular" />
      <item value="parti" />
      <item value="https://github.com/kohlschutter/junixsocket.git" />
      <item value="staging" />
      <item value="use-staging" />
      <item value="datagrams" />
      <item value=" Additionally, you can build and run junixsocket natively on IBM zOS (experimental).&#10; Supports all Java versions since Java 8&#10; Supports both the Java Socket API and NIO " />
      <item value=" Comes with pre-built native libraries for most operating systems and platforms, including&#10;  macOS, Linux, Windows, Solaris, FreeBSD, NetBSD, OpenBSD, DragonFlyBSD, AIX, IBM i." />
      <item value=" junixsocket is the most complete implementation of AF_UNIX sockets for the Java ecosystem.&#10; Supports other socket types, such as TIPC (on Linux) and VSOCK (on Linux, and certain macOS VMs), as well!" />
      <item value="Linux Sensors" />
      <item value="      Number of pages written to pagingswap file(s) to free up space in physical&#10;      memory. Pages are written back to disk only if they are changed in physical&#10;      memory, so they are likely to hold data, not code. A high rate of pages&#10;      output might indicate a memory shortage. The operating system writes more&#10;      pages back to disk to free up space when physical memory is in short supply." />
      <item value="      Number of pages read from pagingswap file(s) to resolve hard page faults.&#10;      (Hard page faults occur when a process requires code or data that is not in&#10;      its working set or elsewhere in physical memory, and must be retrieved from&#10;      disk.) This property was designed as a primary indicator of the kinds of&#10;      faults that cause system-wide delays. It includes pages retrieved to satisfy&#10;      faults in the file system cache (usually requested by applications) and in&#10;      non-cached mapped memory files." />
      <item value="      The memory currently committed by the system, in bytes. Also called the&#10;      Commit Total. This is generally equal to the sum of the bytes used of&#10;      physical memory and pagingswap file(s).&#10;      &lt;p&gt;&#10;      On Windows, committing pages changes this value immediately; however, the&#10;      physical memory is not charged until the pages are accessed, so this value&#10;      may exceed the sum of used physical and pagingswap file memory.&#10;     &#10;      @return Swap used in bytes" />
      <item value="extending" />
      <item value="      The maximum memory that can be committed by the system without extending the&#10;      paging file(s), in bytes. Also called the Commit Limit. If the pagingswap&#10;      file can be extended, this is a soft limit. This is generally equal to the&#10;      sum of the sizes of physical memory and pagingswap file(s)." />
      <item value="      The maximum memory that can be committed by the system without extending the&#10;      paging file(s), in bytes. Also called the Commit Limit. If the pagingswap&#10;      file can be extended, this is a soft limit. This is generally equal to the&#10;      sum of the sizes of physical memory and pagingswap file(s).&#10;      &lt;p&gt;&#10;      On Linux, represents the total amount of memory currently available to be&#10;      allocated on the system based on the overcommit ratio, identified as&#10;      {@code CommitLimit}. This may be higher or lower than the total size of&#10;      physical and swap memory depending on system configuration.&#10;     " />
      <item value="      The current memory committed to the pagingswap file(s), in bytes&#10;     &#10;      @return Swap used in bytes" />
      <item value="      The current size of the pagingswap file(s), in bytes. If the pagingswap&#10;      file can be extended, this is a soft limit." />
      <item value="an array of the system load averages for 1, 5, and 15 minutes with&#10;              the size of the array specified by nelem; or negative values if not&#10;              available." />
      <item value="      @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value=" @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value="      Get System-wide CPU Load tick counters. Returns an array with eight elements&#10;      representing milliseconds spent in User (0), Nice (1), System (2), Idle (3),&#10;      IOwait (4), Hardware interrupts (IRQ) (5), Software interruptsDPC (SoftIRQ)&#10;      (6), or Steal (7) states. Use&#10;      {@link oshi.hardware.CentralProcessor.TickTypegetIndex()} to retrieve the&#10;      appropriate index. By measuring the difference between ticks across a time&#10;      interval, CPU load over that interval may be calculated.&#10;      &lt;p&gt;&#10;      Note that while tick counters are in units of milliseconds, they may advance&#10;      in larger increments along with (platform dependent) clock ticks. For&#10;      example, by default Windows clock ticks are 164 of a second (about 15 or 16&#10;      milliseconds) and Linux ticks are distribution and configuration dependent&#10;      but usually 1100 of a second (10 milliseconds).&#10;      &lt;p&gt;&#10;      Nice and IOWait information is not available on Windows, and IOwait and IRQ&#10;      information is not available on macOS, so these ticks will always be zero.&#10;      &lt;p&gt;&#10;      To calculate overall Idle time using this method, include both Idle and&#10;      IOWait ticks. Similarly, IRQ, SoftIRQ, and Steal ticks should be added to the&#10;      System value to get the total. System ticks also include time executing other&#10;      virtual hosts (steal).&#10;     &#10;      @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1673229698487" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="autoSelectionMode" value="EXCLUSIVE" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>