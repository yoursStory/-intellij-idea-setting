<application>
  <component name="AppStorage">
    <histories>
      <item value="      Overridable method that determines {@link SerializationFeature} that is used as&#10;      the global default in determining if datetime value serialized should use numeric&#10;      format (&quot;timestamp&quot;) or not.&#10;     &lt;p&gt;&#10;      Note that this feature is just the baseline setting and may be overridden on per-type&#10;      or per-property basis." />
      <item value="accpet" />
      <item value="      Constructs an empty array deque with an initial capacity&#10;      sufficient to hold the specified number of elements.&#10;     &#10;      @param numElements lower bound on initial capacity of the deque" />
      <item value="Circular Fifo Queue" />
      <item value="An optionally-bounded blocking deque based on linked nodes.&#10;The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to Integer.MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity.&#10;Most operations run in constant time (ignoring time spent blocking). Exceptions include remove, removeFirstOccurrence, removeLastOccurrence, contains, iterator.remove(), and the bulk operations, all of which run in linear time.&#10;This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces.&#10;This class is a member of the Java Collections Framework." />
      <item value="finger For Save Buffer" />
      <item value="Retains only the elements in this set that are contained in the specified collection (optional operation). In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.&#10;形参:&#10;c – collection containing elements to be retained in this set&#10;返回值:&#10;true if this set changed as a result of the call&#10;抛出:&#10;UnsupportedOperationException – if the retainAll operation is not supported by this set&#10;ClassCastException – if the class of an element of this set is incompatible with the specified collection (optional)&#10;NullPointerException – if this set contains a null element and the specified collection does not permit null elements (optional), or if the specified collection is null&#10;请参阅:&#10;" />
      <item value="origenal" />
      <item value="handle" />
      <item value="audio" />
      <item value="Map Key Genrator" />
      <item value="Map Key Generator" />
      <item value="全局配置" />
      <item value="@SneakyThrow will avoid javac's insistence that you either catch or throw onward any checked exceptions that statements in your method body declare they generate.&#10;@SneakyThrow does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed checked exception types. The JVM does not check for the consistency of the checked exception system; javac does, and this annotation lets you opt out of its mechanism.&#10;Complete documentation is found at the project lombok features page for @SneakyThrows .&#10;Example:&#10;   @SneakyThrows(UnsupportedEncodingException.class)&#10;   public String utf8ToString(byte[] bytes) {&#10;       return new String(bytes, &quot;UTF-8&quot;);&#10;   }&#10;   &#10;Becomes:&#10;   public String utf8ToString(byte[] bytes) {&#10;       try {&#10;           return new String(bytes, &quot;UTF-8&quot;);&#10;       } catch (UnsupportedEncodingException uniqueName) {&#10;           throw useMagicTrickeryToHideThisFromTheCompiler(uniqueName);&#10;            This trickery involves a bytecode transformer run automatically during the final stages of compilation;&#10;            there is no runtime dependency on lombok.&#10;       }&#10;   " />
      <item value="Inclusion mechanism similar to PROPERTY with respect to deserialization; but one that is produced by a &quot;regular&quot; accessible property during serialization. This means that TypeSerializer will do nothing, and expects a property with defined name to be output using some other mechanism (like default POJO property serialization, or custom serializer).&#10;Note that this behavior is quite similar to that of using JsonTypeId annotation; except that here TypeSerializer is basically suppressed; whereas with JsonTypeId, output of regular property is suppressed. This mostly matters with respect to output order; this choice is the only way to ensure specific placement of type id during serialization.&#10;自:&#10;2.3.0 but databind only since 2.5.0." />
      <item value="Inclusion mechanism that wraps typed JSON value (POJO serialized as JSON) in a 2-element JSON array: first element is the serialized type identifier, and second element the serialized POJO as JSON Object." />
      <item value="Inclusion mechanism that wraps typed JSON value (POJO serialized as JSON) in a JSON Object that has a single entry, where field name is serialized type identifier, and value is the actual JSON value.&#10;Note: can only be used if type information can be serialized as String. This is true for standard type metadata types, but not necessarily for custom types." />
      <item value="Inclusion mechanism that uses a single configurable property, included along with actual data (POJO properties) as a separate meta-property.&#10;Default choice for inclusion." />
      <item value="Annotation used for configuring details of if and how type information is used with JSON serialization and deserialization, to preserve information about actual class of Object instances. This is necessarily for polymorphic types, and may also be needed to link abstract declared types and matching concrete implementation.&#10;Some examples of typical annotations:&#10;     Include Java class name (&quot;com.myempl.ImplClass&quot;) as JSON property &quot;class&quot;&#10;    @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property=&quot;class&quot;)&#10;    &#10;     Include logical type name (defined in impl classes) as wrapper; 2 annotations&#10;    @JsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT)&#10;    @JsonSubTypes({com.myemp.Impl1.class, com.myempl.Impl2.class})&#10;  &#10;Alternatively you can also define fully customized type handling by using @JsonTypeResolver annotation (from databind package).&#10;This annotation can be used both for types (classes) and properties. If both exist, annotation on property has precedence, as it is considered more specific.&#10;When used for properties (fields, methods), this annotation applies to values: so when applied to structure types (like java.util.Collection, java.util.Map, arrays), will apply to contained values, not the container; for non-structured types there is no difference. This is identical to how JAXB handles type information annotations; and is chosen since it is the dominant use case. There is no per-property way to force type information to be included for type of container (structured type); for container types one has to use annotation for type declaration.&#10;Note on visibility of type identifier: by default, deserialization (use during reading of JSON) of type identifier is completely handled by Jackson, and is not passed to deserializers. However, if so desired, it is possible to define property visible = true in which case property will be passed as-is to deserializers (and set via setter or field) on deserialization.&#10;On serialization side, Jackson will generate type id by itself, except if there is a property with name that matches property(), in which case value of that property is used instead.&#10;NOTE: use of type id of &quot;class name&quot; with very general base type (such as Object or java.io.Serializable) can potentially open up security holes if deserializing content generated by untrusted sources. If content can not be trusted, it is necessary to either use &quot;type name&quot; as type id, or to limit possible types using other means." />
      <item value="DEDUCTION" />
      <item value="Means that no serialized typing-property is used. Types are deduced based on the fields available. Deduction is limited to the names of fields (not their values or, consequently, any nested descendants). Exceptions will be thrown if not enough unique information is present to select a single subtype. If deduction is being used annotation properties visible, property and include are ignored." />
      <item value="This means that no explicit type metadata is included, and typing is purely done using contextual information possibly augmented with other annotations." />
      <item value="Definition of different type identifiers that can be included in JSON during serialization, and used for deserialization." />
      <item value="Comparable" />
      <item value="comparable" />
      <item value="delta" />
      <item value="Round Robin Load Balancer" />
      <item value="Noop Service Instance List Supplier" />
      <item value="Stream Cluster" />
      <item value="truncated" />
      <item value="Complex Transformer" />
      <item value="on Miss Default Value" />
      <item value="字典" />
      <item value="Complex Transformer Proxy" />
      <item value="  Like the assembly:attached goal, assemble an application bundle or&#10;  distribution using an assembly descriptor from the command line. This goal&#10;  will force Maven to build all included POMs up to the package phase BEFORE the&#10;  assembly is processed. This goal differs from assembly:assembly in that it&#10;  ignores the &lt;formats&gt; section of the assembly descriptor, and forces the&#10;  assembly to be created as a directory in the project's build-output directory&#10;  (usually .target).&#10;  This goal is also functionally equivalent to using the assembly:assembly goal&#10;  in conjunction with the dir assembly format.&#10;  NOTE: This goal should ONLY be run from the command line, and if building a&#10;  multimodule project it should be used from the root POM. Use the&#10;  assembly:directory-single goal for binding your assembly to the lifecycle." />
      <item value="Assemble an application bundle or distribution using an assembly descriptor&#10;  from the command line. This goal will force Maven to build all included POMs&#10;  up to the package phase BEFORE the assembly is processed.&#10;  NOTE: This goal should ONLY be run from the command line, and if building a&#10;  multimodule project it should be used from the root POM. Use the&#10;  assembly:single goal for binding your assembly to the lifecycle." />
      <item value="assembly" />
      <item value="asse" />
      <item value="firewall-cmd --add-port=123/tcp --permanent" />
      <item value="asset Manage CK Info" />
      <item value="  Simple stop watch, allowing for timing of a number of tasks, exposing total&#10;  running time and running time for each named task.&#10; &#10;  &lt;p&gt;Conceals use of {@link SystemnanoTime()}, improving the readability of&#10;  application code and reducing the likelihood of calculation errors.&#10; &#10;  &lt;p&gt;Note that this object is not designed to be thread-safe and does not use&#10;  synchronization.&#10; &#10;  &lt;p&gt;This class is normally used to verify performance during proof-of-concept&#10;  work and in development, rather than as part of production applications.&#10; &#10;  &lt;p&gt;As of Spring Framework 5.2, running time is tracked and reported in" />
      <item value="escalation" />
      <item value="scenario Analysis Report" />
      <item value="demand" />
      <item value="      Returns the trigonometric cosine of an angle. Special cases:&#10;      &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the&#10;      result is NaN.&lt;ul&gt;&#10;     &#10;      &lt;p&gt;The computed result must be within 1 ulp of the exact result.&#10;      Results must be semi-monotonic." />
      <item value="  Instances of this class support both reading and writing to a&#10;  random access file. A random access file behaves like a large&#10;  array of bytes stored in the file system. There is a kind of cursor,&#10;  or index into the implied array, called the &lt;em&gt;file pointer&lt;em&gt;;&#10;  input operations read bytes starting at the file pointer and advance&#10;  the file pointer past the bytes read. If the random access file is&#10;  created in readwrite mode, then output operations are also available;&#10;  output operations write bytes starting at the file pointer and advance&#10;  the file pointer past the bytes written. Output operations that write&#10;  past the current end of the implied array cause the array to be&#10;  extended. The file pointer can be read by the&#10;  {@code getFilePointer} method and set by the {@code seek}&#10;  method.&#10;  &lt;p&gt;&#10;  It is generally true of all the reading routines in this class that&#10;  if end-of-file is reached before the desired number of bytes has been&#10;  read, an {@code EOFException} (which is a kind of&#10;  {@code IOException}) is thrown. If any byte cannot be read for&#10;  any reason other than end-of-file, an {@code IOException} other&#10;  than {@code EOFException} is thrown. In particular, an&#10;  {@code IOException} may be thrown if the stream has been closed." />
      <item value="Reads in &lt;b&gt;little endian&lt;b&gt; order, as required by the zipfile&#10;  format." />
      <item value="max Fill Read Capacity" />
      <item value="      Waits at most {@code millis} milliseconds for this thread to&#10;      die. A timeout of {@code 0} means to wait forever.&#10;     &#10;      &lt;p&gt; This implementation uses a loop of {@code this.wait} calls&#10;      conditioned on {@code this.isAlive}. As a thread terminates the&#10;      {@code this.notifyAll} method is invoked. It is recommended that&#10;      applications not use {@code wait}, {@code notify}, or&#10;      {@code notifyAll} on {@code Thread} instances." />
      <item value="Method called to assign value serializer for property" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="683" />
        <entry key="ENGLISH" value="684" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662530711519" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>