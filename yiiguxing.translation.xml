<application>
  <component name="AppStorage">
    <histories>
      <item value="Intrinsic Candidate" />
      <item value="is Assignable From" />
      <item value="  * Determines if the class or interface represented by this&#10;     * {@code Class} object is either the same as, or is a superclass or&#10;     * superinterface of, the class or interface represented by the specified&#10;     * {@code Class} parameter. It returns {@code true} if so;&#10;     * otherwise it returns {@code false}. If this {@code Class}&#10;     * object represents a primitive type, this method returns&#10;     * {@code true} if the specified {@code Class} parameter is&#10;     * exactly this {@code Class} object; otherwise it returns&#10;     * {@code false}.&#10;     *&#10;     * &lt;p&gt; Specifically, this method tests whether the type represented by the&#10;     * specified {@code Class} parameter can be converted to the type&#10;     * represented by this {@code Class} object via an identity conversion&#10;     * or via a widening reference conversion. See &lt;cite&gt;The Java Language&#10;     * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},&#10;     * for details." />
      <item value="structured" />
      <item value="compared" />
      <item value=" * Vanilla {@link com.fasterxml.jackson.databind.Module} implementation that allows registration&#10; * of serializers and deserializers, bean serializer&#10; * and deserializer modifiers, registration of subtypes and mix-ins&#10; * as well as some other commonly&#10; * needed aspects (addition of custom {@link AbstractTypeResolver}s,&#10; * {@link com.fasterxml.jackson.databind.deser.ValueInstantiator}s).&#10; *&lt;p&gt;&#10; * NOTE: although it is not expected that sub-types should need to&#10; * override {@link #setupModule(SetupContext)} method, if they choose&#10; * to do so they MUST call {@code super.setupModule(context);}&#10; * to ensure that registration works as expected.&#10; *&lt;p&gt;&#10; * WARNING: when registering {@link JsonSerializer}s and {@link JsonDeserializer}s,&#10; * only type erased {@code Class} is compared: this means that usually you should&#10; * NOT use this implementation for registering structured types such as&#10; * {@link java.util.Collection}s or {@link java.util.Map}s: this because parametric&#10; * type information will not be considered and you may end up having &quot;wrong&quot; handler&#10; * for your type.&#10; * What you need to do, instead, is to implement {@link com.fasterxml.jackson.databind.deser.Deserializers} &#10; * and/or {@link com.fasterxml.jackson.databind.ser.Serializers} callbacks to match full type&#10; * signatures (with {@link JavaType})." />
      <item value="create Contextual" />
      <item value=" * Add-on interface that {@link JsonSerializer}s can implement to get a callback&#10; * that can be used to create contextual instances of serializer to use for&#10; * handling properties of supported type. This can be useful&#10; * for serializers that can be configured by annotations, or should otherwise&#10; * have differing behavior depending on what kind of property is being serialized.&#10; *&lt;p&gt;&#10; * Note that in cases where serializer needs both contextualization and&#10; * resolution -- that is, implements both this interface and {@link ResolvableSerializer}&#10; * -- resolution via {@link ResolvableSerializer} occurs first, and contextual&#10; * resolution (via this interface) later on." />
      <item value="     * Method called to see if a different (or differently configured) serializer&#10;     * is needed to serialize values of specified property.&#10;     * Note that instance that this method is called on is typically shared one and&#10;     * as a result method should &lt;b&gt;NOT&lt;/b&gt; modify this instance but rather construct&#10;     * and return a new instance. This instance should only be returned as-is, in case&#10;     * it is already suitable for use.&#10;     * &#10;     * @param prov Serializer provider to use for accessing config, other serializers&#10;     * @param property Method or field that represents the property&#10;     *   (and is used to access value to serialize).&#10;     *   Should be available; but there may be cases where caller cannot provide it and&#10;     *   null is passed instead (in which case impls usually pass 'this' serializer as is)&#10;     * &#10;     * @return Serializer to use for serializing values of specified property;&#10;     *   may be this instance or a new instance." />
      <item value="Desensitize" />
      <item value="Phone Desensitize" />
      <item value="desensitization" />
      <item value="validate If Applicable" />
      <item value="determine Group Validation Order" />
      <item value="process Constraint Violations" />
      <item value="Violation Field Error" />
      <item value="intern" />
      <item value="interned" />
      <item value="     * Returns a canonical representation for the string object.&#10;     * &lt;p&gt;&#10;     * A pool of strings, initially empty, is maintained privately by the&#10;     * class {@code String}.&#10;     * &lt;p&gt;&#10;     * When the intern method is invoked, if the pool already contains a&#10;     * string equal to this {@code String} object as determined by&#10;     * the {@link #equals(Object)} method, then the string from the pool is&#10;     * returned. Otherwise, this {@code String} object is added to the&#10;     * pool and a reference to this {@code String} object is returned.&#10;     * &lt;p&gt;&#10;     * It follows that for any two strings {@code s} and {@code t},&#10;     * {@code s.intern() == t.intern()} is {@code true}&#10;     * if and only if {@code s.equals(t)} is {@code true}.&#10;     * &lt;p&gt;&#10;     * All literal strings and string-valued constant expressions are&#10;     * interned. String literals are defined in section 3.10.5 of the&#10;     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.&#10;     *&#10;     * @return  a string that has the same contents as this string, but is&#10;     *          guaranteed to be from a pool of unique strings." />
      <item value="is Eligible For Overriding" />
      <item value="     * Returns a set backed by the specified map.  The resulting set displays&#10;     * the same ordering, concurrency, and performance characteristics as the&#10;     * backing map.  In essence, this factory method provides a {@link Set}&#10;     * implementation corresponding to any {@link Map} implementation.  There&#10;     * is no need to use this method on a {@link Map} implementation that&#10;     * already has a corresponding {@link Set} implementation (such as {@link&#10;     * HashMap} or {@link TreeMap}).&#10;     *&#10;     * &lt;p&gt;Each method invocation on the set returned by this method results in&#10;     * exactly one method invocation on the backing map or its &lt;tt&gt;keySet&lt;/tt&gt;&#10;     * view, with one exception.  The &lt;tt&gt;addAll&lt;/tt&gt; method is implemented&#10;     * as a sequence of &lt;tt&gt;put&lt;/tt&gt; invocations on the backing map.&#10;     *&#10;     * &lt;p&gt;The specified map must be empty at the time this method is invoked,&#10;     * and should not be accessed directly after this method returns.  These&#10;     * conditions are ensured if the map is created empty, passed directly&#10;     * to this method, and no reference to the map is retained, as illustrated&#10;     * in the following code fragment:&#10;     * &lt;pre&gt;" />
      <item value="     * Returns a set backed by the specified map.  The resulting set displays&#10;     * the same ordering, concurrency, and performance characteristics as the&#10;     * backing map.  In essence, this factory method provides a {@link Set}&#10;     * implementation corresponding to any {@link Map} implementation.  There&#10;     * is no need to use this method on a {@link Map} implementation that&#10;     * already has a corresponding {@link Set} implementation (such as {@link&#10;     * HashMap} or {@link TreeMap}).&#10;     *&#10;     * &lt;p&gt;Each method invocation on the set returned by this method results in&#10;     * exactly one method invocation on the backing map or its &lt;tt&gt;keySet&lt;/tt&gt;&#10;     * view, with one exception.  The &lt;tt&gt;addAll&lt;/tt&gt; method is implemented&#10;     * as a sequence of &lt;tt&gt;put&lt;/tt&gt; invocations on the backing map.&#10;     *&#10;     * &lt;p&gt;The specified map must be empty at the time this method is invoked,&#10;     * and should not be accessed directly after this method returns.  These&#10;     * conditions are ensured if the map is created empty, passed directly&#10;     * to this method, and no reference to the map is retained, as illustrated&#10;     * in the following code fragment:&#10;     * &lt;pre&gt;&#10;     *    Set&amp;lt;Object&amp;gt; weakHashSet = Collections.newSetFromMap(&#10;     *        new WeakHashMap&amp;lt;Object, Boolean&amp;gt;());&#10;     * &lt;/pre&gt;" />
      <item value="override Delegate" />
      <item value="     * Registers the caller as parallel capable.&#10;     * The registration succeeds if and only if all of the following&#10;     * conditions are met:&#10;     * &lt;ol&gt;&#10;     * &lt;li&gt; no instance of the caller has been created&lt;/li&gt;&#10;     * &lt;li&gt; all of the super classes (except class Object) of the caller are&#10;     * registered as parallel capable&lt;/li&gt;&#10;     * &lt;/ol&gt;&#10;     * &lt;p&gt;Note that once a class loader is registered as parallel capable, there&#10;     * is no way to change it back.&lt;/p&gt;&#10;     *&#10;     * @return  true if the caller is successfully registered as&#10;     *          parallel capable and false if otherwise." />
      <item value=" * {@code ClassLoader} that does &lt;i&gt;not&lt;/i&gt; always delegate to the parent loader&#10; * as normal class loaders do. This enables, for example, instrumentation to be&#10; * forced in the overriding ClassLoader, or a &quot;throwaway&quot; class loading behavior&#10; * where selected application classes are temporarily loaded in the overriding&#10; * {@code ClassLoader} for introspection purposes before eventually loading an&#10; * instrumented version of the class in the given parent {@code ClassLoader}.&#10; *" />
      <item value="subtype" />
      <item value="Caller Sensitive" />
      <item value="     * Returns the context ClassLoader for this Thread. The context&#10;     * ClassLoader is provided by the creator of the thread for use&#10;     * by code running in this thread when loading classes and resources.&#10;     * If not {@linkplain #setContextClassLoader set}, the default is the&#10;     * ClassLoader context of the parent Thread. The context ClassLoader of the&#10;     * primordial thread is typically set to the class loader used to load the&#10;     * application.&#10;     *&#10;     * &lt;p&gt;If a security manager is present, and the invoker's class loader is not&#10;     * {@code null} and is not the same as or an ancestor of the context class&#10;     * loader, then this method invokes the security manager's {@link&#10;     * SecurityManager#checkPermission(java.security.Permission) checkPermission}&#10;     * method with a {@link RuntimePermission RuntimePermission}{@code&#10;     * (&quot;getClassLoader&quot;)} permission to verify that retrieval of the context&#10;     * class loader is permitted." />
      <item value="&#10; * &lt;p&gt; If a particular concrete provider class is named in more than one&#10; * configuration file, or is named in the same configuration file more than&#10; * once, then the duplicates are ignored.  The configuration file naming a&#10; * particular provider need not be in the same jar file or other distribution&#10; * unit as the provider itself.  The provider must be accessible from the same&#10; * class loader that was initially queried to locate the configuration file;&#10; * note that this is not necessarily the class loader from which the file was&#10; * actually loaded.&#10; *&#10; * &lt;p&gt; Providers are located and instantiated lazily, that is, on demand.  A&#10; * service loader maintains a cache of the providers that have been loaded so&#10; * far.  Each invocation of the {@link #iterator iterator} method returns an&#10; * iterator that first yields all of the elements of the cache, in&#10; * instantiation order, and then lazily locates and instantiates any remaining&#10; * providers, adding each one to the cache in turn.  The cache can be cleared&#10; * via the {@link #reload reload} method.&#10; *&#10; * &lt;p&gt; Service loaders always execute in the security context of the caller.&#10; * Trusted system code should typically invoke the methods in this class, and&#10; * the methods of the iterators which they return, from within a privileged&#10; * security context.&#10; *&#10; * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent&#10; * threads." />
      <item value=" A simple service-provider loading facility.&#10; *&#10; * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known set of interfaces and (usually&#10; * abstract) classes.  A &lt;i&gt;service provider&lt;/i&gt; is a specific implementation&#10; * of a service.  The classes in a provider typically implement the interfaces&#10; * and subclass the classes defined in the service itself.  Service providers&#10; * can be installed in an implementation of the Java platform in the form of&#10; * extensions, that is, jar files placed into any of the usual extension&#10; * directories.  Providers can also be made available by adding them to the&#10; * application's class path or by some other platform-specific means.&#10; *&#10; * &lt;p&gt; For the purpose of loading, a service is represented by a single type,&#10; * that is, a single interface or abstract class.  (A concrete class can be&#10; * used, but this is not recommended.)  A provider of a given service contains&#10; * one or more concrete classes that extend this &lt;i&gt;service type&lt;/i&gt; with data&#10; * and code specific to the provider.  The &lt;i&gt;provider class&lt;/i&gt; is typically&#10; * not the entire provider itself but rather a proxy which contains enough&#10; * information to decide whether the provider is able to satisfy a particular&#10; * request together with code that can create the actual provider on demand.&#10; * The details of provider classes tend to be highly service-specific; no&#10; * single class or interface could possibly unify them, so no such type is&#10; * defined here.  The only requirement enforced by this facility is that&#10; * provider classes must have a zero-argument constructor so that they can be&#10; * instantiated during loading." />
      <item value=" * &lt;li&gt; to decide whether an access to a critical system&#10; * resource is to be allowed or denied, based on the security policy&#10; * currently in effect,&#10; * &lt;li&gt;to mark code as being &quot;privileged&quot;, thus affecting subsequent&#10; * access determinations, and&#10; * &lt;li&gt;to obtain a &quot;snapshot&quot; of the current calling context so&#10; * access-control decisions from a different context can be made with&#10; * respect to the saved context. &lt;/ul&gt;&#10; *&#10; * &lt;p&gt; The {@link #checkPermission(Permission) checkPermission} method&#10; * determines whether the access request indicated by a specified&#10; * permission should be granted or denied. A sample call appears&#10; * below. In this example, {@code checkPermission} will determine&#10; * whether or not to grant &quot;read&quot; access to the file named &quot;testFile&quot; in&#10; * the &quot;/temp&quot; directory." />
      <item value="     * Performs the specified {@code PrivilegedAction} with privileges&#10;     * enabled. The action is performed with &lt;i&gt;all&lt;/i&gt; of the permissions&#10;     * possessed by the caller's protection domain.&#10;     *&#10;     * &lt;p&gt; If the action's {@code run} method throws an (unchecked)&#10;     * exception, it will propagate through this method.&#10;     *&#10;     * &lt;p&gt; Note that any DomainCombiner associated with the current&#10;     * AccessControlContext will be ignored while the action is performed.&#10;     *&#10;     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's&#10;     *                  {@code run} method.&#10;     *&#10;     * @param action the action to be performed.&#10;     *&#10;     * @return the value returned by the action's {@code run} method.&#10;     *&#10;     * @exception NullPointerException if the action is {@code null}" />
      <item value="Hashed Wheel Bucket" />
      <item value="normalized Ticks Per Wheel" />
      <item value="check Positive" />
      <item value="associated" />
      <item value="Timer Utils" />
      <item value="transient" />
      <item value="&#9; * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this&#10;&#9; * application of an application event. Events may be framework events&#10;&#9; * (such as ContextRefreshedEvent) or application-specific events.&#10;&#9; * &lt;p&gt;Such an event publication step is effectively a hand-off to the&#10;&#9; * multicaster and does not imply synchronous/asynchronous execution&#10;&#9; * or even immediate execution at all. Event listeners are encouraged&#10;&#9; * to be as efficient as possible, individually using asynchronous&#10;&#9; * execution for longer-running and potentially blocking operations.&#10;&#9; * @param event the event to publish" />
      <item value=" *     &lt;li&gt;get all subtypes of some type&#10; *     &lt;li&gt;get all types/constructors/methods/fields annotated with some annotation, optionally with annotation parameters matching&#10; *     &lt;li&gt;get all resources matching matching a regular expression&#10; *     &lt;li&gt;get all methods with specific signature including parameters, parameter annotations and return type&#10; *     &lt;li&gt;get all methods parameter names&#10; *     &lt;li&gt;get all fields/methods/constructors usages in code" />
      <item value="* Reflections one-stop-shop object&#10; * &lt;p&gt;Reflections scans your classpath, indexes the metadata, allows you to query it on runtime and may save and collect that information for many modules within your project.&#10; * &lt;p&gt;Using Reflections you can query your metadata such as:" />
      <item value="referer" />
      <item value="转介绍" />
      <item value="receiveintroduction" />
      <item value="communicate Record" />
      <item value="     * The main pool control state, ctl, is an atomic integer packing&#10;     * two conceptual fields&#10;     *   workerCount, indicating the effective number of threads&#10;     *   runState,    indicating whether running, shutting down etc&#10;     *&#10;     * In order to pack them into one int, we limit workerCount to&#10;     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2&#10;     * billion) otherwise representable. If this is ever an issue in&#10;     * the future, the variable can be changed to be an AtomicLong,&#10;     * and the shift/mask constants below adjusted. But until the need&#10;     * arises, this code is a bit faster and simpler using an int.&#10;     *&#10;     * The workerCount is the number of workers that have been&#10;     * permitted to start and not permitted to stop.  The value may be&#10;     * transiently different from the actual number of live threads,&#10;     * for example when a ThreadFactory fails to create a thread when&#10;     * asked, and when exiting threads are still performing&#10;     * bookkeeping before terminating. The user-visible pool size is&#10;     * reported as the current size of the workers set.&#10;     *&#10;     * The runState provides the main lifecycle control, taking on values:&#10;     *&#10;     *   RUNNING:  Accept new tasks and process queued tasks&#10;     *   SHUTDOWN: Don't accept new tasks, but process queued tasks&#10;     *   STOP:     Don't accept new tasks, don't process queued tasks,&#10;     *             and interrupt in-progress tasks&#10;     *   TIDYING:  All tasks have terminated, workerCount is zero,&#10;     *             the thread transitioning to state TIDYING&#10;     *             will run the terminated() hook method&#10;     *   TERMINATED: terminated() has completed&#10;     *&#10;     * The numerical order among these values matters, to allow&#10;     * ordered comparisons. The runState monotonically increases over&#10;     * time, but need not hit each state. The transitions are:&#10;     *&#10;     * RUNNING -&gt; SHUTDOWN&#10;     *    On invocation of shutdown(), perhaps implicitly in finalize()&#10;     * (RUNNING or SHUTDOWN) -&gt; STOP&#10;     *    On invocation of shutdownNow()&#10;     * SHUTDOWN -&gt; TIDYING&#10;     *    When both queue and pool are empty&#10;     * STOP -&gt; TIDYING&#10;     *    When pool is empty&#10;     * TIDYING -&gt; TERMINATED&#10;     *    When the terminated() hook method has completed&#10;     *&#10;     * Threads waiting in awaitTermination() will return when the&#10;     * state reaches TERMINATED.&#10;     *&#10;     * Detecting the transition from SHUTDOWN to TIDYING is less&#10;     * straightforward than you'd like because the queue may become&#10;     * empty after non-empty and vice versa during SHUTDOWN state, but&#10;     * we can only terminate if, after seeing that it is empty, we see&#10;     * that workerCount is 0 (which sometimes entails a recheck -- see&#10;     * below)." />
      <item value="         *&#10;         * 1. If fewer than corePoolSize threads are running, try to&#10;         * start a new thread with the given command as its first&#10;         * task.  The call to addWorker atomically checks runState and&#10;         * workerCount, and so prevents false alarms that would add&#10;         * threads when it shouldn't, by returning false.&#10;         *&#10;         * 2. If a task can be successfully queued, then we still need&#10;         * to double-check whether we should have added a thread&#10;         * (because existing ones died since last checking) or that&#10;         * the pool shut down since entry into this method. So we&#10;         * recheck state and if necessary roll back the enqueuing if&#10;         * stopped, or start a new thread if there are none.&#10;         *&#10;         * 3. If we cannot queue task, then we try to add a new&#10;         * thread.  If it fails, we know we are shut down or saturated&#10;         * and so reject the task." />
      <item value="  * Executes the given task sometime in the future.  The task&#10;     * may execute in a new thread or in an existing pooled thread.&#10;     *&#10;     * If the task cannot be submitted for execution, either because this&#10;     * executor has been shutdown or because its capacity has been reached,&#10;     * the task is handled by the current {@code RejectedExecutionHandler}.&#10;     *&#10;     * @param command the task to execute&#10;     * @throws RejectedExecutionException at discretion of&#10;     *         {@code RejectedExecutionHandler}, if the task&#10;     *         cannot be accepted for execution&#10;     * @throws NullPointerException if {@code command} is null" />
      <item value="finalizer" />
      <item value=" * Generates dynamic subclasses to enable method interception. This&#10; * class started as a substitute for the standard Dynamic Proxy support&#10; * included with JDK 1.3, but one that allowed the proxies to extend a&#10; * concrete base class, in addition to implementing interfaces. The dynamically&#10; * generated subclasses override the non-final methods of the superclass and&#10; * have hooks which callback to user-defined interceptor&#10; * implementations.&#10; * &lt;p&gt;&#10; * The original and most general callback type is the {@link MethodInterceptor}, which&#10; * in AOP terms enables &quot;around advice&quot;--that is, you can invoke custom code both before&#10; * and after the invocation of the &quot;super&quot; method. In addition you can modify the&#10; * arguments before calling the super method, or not call it at all.&#10; * &lt;p&gt;&#10; * Although &lt;code&gt;MethodInterceptor&lt;/code&gt; is generic enough to meet any&#10; * interception need, it is often overkill. For simplicity and performance, additional&#10; * specialized callback types, such as {@link LazyLoader} are also available.&#10; * Often a single callback will be used per enhanced class, but you can control&#10; * which callback is used on a per-method basis with a {@link CallbackFilter}.&#10; * &lt;p&gt;&#10; * The most common uses of this class are embodied in the static helper methods. For&#10; * advanced needs, such as customizing the &lt;code&gt;ClassLoader&lt;/code&gt; to use, you should create&#10; * a new instance of &lt;code&gt;Enhancer&lt;/code&gt;. Other classes within CGLIB follow a similar pattern.&#10; * &lt;p&gt;&#10; * All enhanced objects implement the {@link Factory} interface, unless {@link #setUseFactory} is&#10; * used to explicitly disable this feature. The &lt;code&gt;Factory&lt;/code&gt; interface provides an API&#10; * to change the callbacks of an existing object, as well as a faster and easier way to create&#10; * new instances of the same type.&#10; * &lt;p&gt;&#10; * For an almost drop-in replacement for&#10; * &lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt;, see the {@link Proxy} class" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="657" />
        <entry key="ENGLISH" value="633" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>