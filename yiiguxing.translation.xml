<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="2703" />
    <option name="newTranslationDialogY" value="454" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Velocity Engine" />
      <item value="&#9;  Returns the constraint metadata reported to fail.&#10;&#9;  The returned instance is immutable." />
      <item value="executable Return Value" />
      <item value="executable Parameters" />
      <item value="interpolated Message" />
      <item value="expression Variables" />
      <item value="Constraint Violation" />
      <item value="is Assignable From" />
      <item value="&#9;  @param type The type of payload to retrieve&#10;&#9;  @return an instance of the specified type set by the user via&#10;&#9;  {@link HibernateConstraintValidatorContextwithDynamicPayload(Object)} or {@code null} if no constraint payload&#10;&#9;  if the given type has been set." />
      <item value="  Describes a constraint violation. This object exposes the constraint&#10;  violation context as well as the message describing the violation." />
      <item value="transient" />
      <item value="canonical Field Name" />
      <item value="  Enumeration for basic token types used for returning results&#10;  of parsing JSON content." />
      <item value="  {@link HttpInputMessage} that can eventually stores a Jackson view that will be used&#10;  to deserialize the message." />
      <item value="  Marker annotation that indicates that the annotated method&#10;  or field should be serialized by including literal String value&#10;  of the property as is, without quoting of characters.&#10;  This can be useful for injecting values already serialized in JSON or &#10;  passing javascript function definitions from server to a javascript client.&#10; &lt;p&gt;&#10;  Warning: the resulting JSON stream may be invalid depending on your input value." />
      <item value="  A custom {@link ConstraintViolation} which allows to get additional information for a constraint violation.&#10; " />
      <item value="     The '(' numeric flag may be used to format negative numbers with&#10;     parentheses rather than a minus sign.  Group separators are&#10;     automatically inserted." />
      <item value="  &lt;p&gt; Formatted printing for the Java language is heavily inspired by C's&#10;  {@code printf}.  Although the format strings are similar to C, some&#10;  customizations have been made to accommodate the Java language and exploit&#10;  some of its features.  Also, Java formatting is more strict than C's; for&#10;  example, if a conversion is incompatible with a flag, an exception will be&#10;  thrown.  In C inapplicable flags are silently ignored.  The format strings&#10;  are thus intended to be recognizable to C programmers but not necessarily&#10;  completely compatible with those in C." />
      <item value=" &lt;p&gt; Formatters are not necessarily safe for multithreaded access.  Thread&#10;  safety is optional and is the responsibility of users of methods in this&#10;  class." />
      <item value="  An interpreter for printf-style format strings.  This class provides support&#10;  for layout justification and alignment, common formats for numeric, string,&#10;  and datetime data, and locale-specific output.  Common Java types such as&#10;  {@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}&#10;  are supported.  Limited formatting customization for arbitrary user types is&#10;  provided through the {@link Formattable} interface.&#10; &#10;  &lt;p&gt; Formatters are not necessarily safe for multithreaded access.  Thread&#10;  safety is optional and is the responsibility of users of methods in this&#10;  class." />
      <item value="&#9;&#10;&#9;  Interpolates given term based on the constraint validation context.&#10;&#9; &#10;&#9;  @param term the message to interpolate&#10;&#9;  @param context contextual information related to the interpolation&#10;&#9; &#10;&#9;  @return interpolated message" />
      <item value="interpolate" />
      <item value="Resolves" />
      <item value="contributor" />
      <item value="constraint" />
      <item value="&#9;  {@code MessageInterpolator} taking two resource bundle locators.&#10;&#9; &#10;&#9;  @param userResourceBundleLocator {@code ResourceBundleLocator} used to load user provided resource bundle&#10;&#9;  @param contributorResourceBundleLocator {@code ResourceBundleLocator} used to load resource bundle of constraint&#10;&#9;  contributor&#10;&#9;  @param locales the set of locales to initialize at bootstrap&#10;&#9;  @param defaultLocale the default locale&#10;&#9;  @param cacheMessages whether resolved messages should be cached or not&#10;&#9;  @param localeResolver the locale resolver&#10;&#9;  @param preloadResourceBundles if the resource bundled should be initialized at initialization time, this is useful in the case of a" />
      <item value="Interpolator" />
      <item value="Abstract Message Interpolator" />
      <item value="  Define the strategy used to resolve the locale user for message interpolation when no locale is defined from the list&#10;  of supported locales.&#10; " />
      <item value="get Default Validation Provider Resolver" />
      <item value="      Return the version of this implementation. It consists of any string&#10;      assigned by the vendor of this implementation and does&#10;      not have any particular syntax specified or expected by the Java&#10;      runtime. It may be compared for equality with other&#10;      package version strings used for this implementation&#10;      by this vendor for this package.&#10;      @return the version of the implementation, {@code null} is returned if it is not known." />
      <item value="external Class Loader" />
      <item value="      Copies the specified range of the specified array into a new array.&#10;      The initial index of the range ({@code from}) must lie between zero&#10;      and {@code original.length}, inclusive.  The value at&#10;      {@code original[from]} is placed into the initial element of the copy&#10;      (unless {@code from == original.length} or {@code from == to}).&#10;      Values from subsequent elements in the original array are placed into&#10;      subsequent elements in the copy.  The final index of the range&#10;      ({@code to}), which must be greater than or equal to {@code from},&#10;      may be greater than {@code original.length}, in which case&#10;      {@code null} is placed in all elements of the copy whose index is&#10;      greater than or equal to {@code original.length - from}.  The length&#10;      of the returned array will be {@code to - from}.&#10;      The resulting array is of the class {@code newType}." />
      <item value="  performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the&#10;  Java libraries and is therefore not supposed to have any relevance for application&#10;  code." />
      <item value="assembly" />
      <item value="  The {@code @HotSpotIntrinsicCandidate} annotation is specific to the&#10;  HotSpot Virtual Machine. It indicates that an annotated method&#10;  may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method&#10;  is intrinsified if the HotSpot VM replaces the annotated method with hand-written&#10;  assembly andor hand-written compiler IR -- a compiler intrinsic -- to improve&#10;  performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the&#10;  Java libraries and is therefore not supposed to have any relevance for application&#10;  code.&#10; &#10;  Maintainers of the Java libraries must consider the following when&#10;  modifying methods annotated with {@code @HotSpotIntrinsicCandidate}.&#10; " />
      <item value="  The {@code @HotSpotIntrinsicCandidate} annotation is specific to the&#10;  HotSpot Virtual Machine. It indicates that an annotated method&#10;  may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method&#10;  is intrinsified if the HotSpot VM replaces the annotated method with hand-written&#10;  assembly andor hand-written compiler IR -- a compiler intrinsic -- to improve&#10;  performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the&#10;  Java libraries and is therefore not supposed to have any relevance for application&#10;  code.&#10; &#10;  Maintainers of the Java libraries must consider the following when&#10;  modifying methods annotated with {@code @HotSpotIntrinsicCandidate}.&#10; &#10;  &lt;ul&gt;&#10;  &lt;li&gt;When modifying a method annotated with {@code @HotSpotIntrinsicCandidate},&#10;  the corresponding intrinsic code in the HotSpot VM implementation must be&#10;  updated to match the semantics of the annotated method.&lt;li&gt;&#10;  &lt;li&gt;For some annotated methods, the corresponding intrinsic may omit some low-level&#10;  checks that would be performed as a matter of course if the intrinsic is implemented&#10;  using Java bytecodes. This is because individual Java bytecodes implicitly check&#10;  for exceptions like {@code NullPointerException} and {@code ArrayStoreException}.&#10;  If such a method is replaced by an intrinsic coded in assembly language, any&#10;  checks performed as a matter of normal bytecode operation must be performed&#10;  before entry into the assembly code. These checks must be performed, as&#10;  appropriate, on all arguments to the intrinsic, and on other values (if any) obtained&#10;  by the intrinsic through those arguments. The checks may be deduced by inspecting&#10;  the non-intrinsic Java code for the method, and determining exactly which exceptions&#10;  may be thrown by the code, including undeclared implicit {@code RuntimeException}s.&#10;  Therefore, depending on the data accesses performed by the intrinsic,&#10;  the checks may include:&#10; &#10;   &lt;ul&gt;&#10;   &lt;li&gt;null checks on references&lt;li&gt;&#10;   &lt;li&gt;range checks on primitive values used as array indexes&lt;li&gt;&#10;   &lt;li&gt;other validity checks on primitive values (e.g., for divide-by-zero conditions)&lt;li&gt;&#10;   &lt;li&gt;store checks on reference values stored into arrays&lt;li&gt;&#10;   &lt;li&gt;array length checks on arrays indexed from within the intrinsic&lt;li&gt;&#10;   &lt;li&gt;reference casts (when formal parameters are {@code Object} or some other weak type)&lt;li&gt;&#10;   &lt;ul&gt;&#10; &#10;  &lt;li&gt;&#10; &#10;  &lt;li&gt;Note that the receiver value ({@code this}) is passed as a extra argument&#10;  to all non-static methods. If a non-static method is an intrinsic, the receiver&#10;  value does not need a null check, but (as stated above) any values loaded by the&#10;  intrinsic from object fields must also be checked. As a matter of clarity, it is&#10;  better to make intrinisics be static methods, to make the dependency on {@code this}&#10;  clear. Also, it is better to explicitly load all required values from object&#10;  fields before entering the intrinsic code, and pass those values as explicit arguments.&#10;  First, this may be necessary for null checks (or other checks). Second, if the&#10;  intrinsic reloads the values from fields and operates on those without checks,&#10;  race conditions may be able to introduce unchecked invalid values into the intrinsic.&#10;  If the intrinsic needs to store a value back to an object field, that value should be&#10;  returned explicitly from the intrinsic; if there are multiple return values, coders&#10;  should consider buffering them in an array. Removing field access from intrinsics&#10;  not only clarifies the interface with between the JVM and JDK; it also helps decouple&#10;  the HotSpot and JDK implementations, since if JDK code before and after the intrinsic&#10;  manages all field accesses, then intrinsics can be coded to be agnostic of object&#10;  layouts.&lt;li&gt;&#10; &#10;  Maintainers of the HotSpot VM must consider the following when modifying&#10;  intrinsics.&#10; &#10;  &lt;ul&gt;&#10;  &lt;li&gt;When adding a new intrinsic, make sure that the corresponding method&#10;  in the Java libraries is annotated with {@code @HotSpotIntrinsicCandidate}&#10;  and that all possible call sequences that result in calling the intrinsic contain&#10;  the checks omitted by the intrinsic (if any).&lt;li&gt;&#10;  &lt;li&gt;When modifying an existing intrinsic, the Java libraries must be updated&#10;  to match the semantics of the intrinsic and to execute all checks omitted&#10;  by the intrinsic (if any).&lt;li&gt;&#10;  &lt;ul&gt;&#10; &#10;  Persons not directly involved with maintaining the Java libraries or the&#10;  HotSpot VM can safely ignore the fact that a method is annotated with&#10;  {@code @HotSpotIntrinsicCandidate}.&#10; &#10;  The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic&#10;  are available on all platforms supported by the HotSpot VM. Furthermore,&#10;  the availability of an intrinsic on a given platform depends on the&#10;  configuration of the HotSpot VM (e.g., the set of VM flags enabled).&#10;  Therefore, annotating a method with {@code @HotSpotIntrinsicCandidate} does&#10;  not guarantee that the marked method is intrinsified by the HotSpot VM.&#10; &#10;  If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks&#10;  (when loading a class) that (1) all methods of that class that are also on&#10;  the VM's list of intrinsics are annotated with {@code @HotSpotIntrinsicCandidate}&#10;  and that (2) for all methods of that class annotated with&#10;  {@code @HotSpotIntrinsicCandidate} there is an intrinsic in the list." />
      <item value="Hot Spot Intrinsic Candidate" />
      <item value="component" />
      <item value="_copy Stack Trace Minus One" />
      <item value="Warning this class consists of generated code." />
      <item value="     Returns the class of the caller of the method calling this method,&#10;        ignoring frames associated with java.lang.reflect.Method.invoke()&#10;        and its implementation. " />
      <item value="  This class consists exclusively of static methods that operate on or return&#10;  method handles. They fall into several categories:&#10;  &lt;ul&gt;&#10;  &lt;li&gt;Lookup methods which help create method handles for methods and fields.&#10;  &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.&#10;  &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.&#10;  &lt;ul&gt;&#10; " />
      <item value="Predefined Scope Validator Factory Impl" />
      <item value="incubating" />
      <item value="encouraged" />
      <item value="  Marks the annotated element as incubating. The contract of incubating elements (e.g. packages, types, methods,&#10;  constants etc.) is under active development and may be incompatibly altered - or removed - in subsequent releases.&#10;  &lt;p&gt;&#10;  Usage of incubating APISPI members is encouraged (so the development team can get feedback on these new features)&#10;  but you should be prepared for updating code which is using them as needed." />
      <item value="Incubating" />
      <item value="  Provides Hibernate Validator extensions to {@link ValidatorFactory} in the context of a predefined scope." />
      <item value="visible side effect" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1668074231743" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>