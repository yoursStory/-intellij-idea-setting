<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="584" />
    <option name="newTranslationDialogX" value="2783" />
    <option name="newTranslationDialogY" value="225" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="      @param fromIndex low endpoint (inclusive) of the subList&#10;      @param toIndex high endpoint (exclusive) of the subList&#10;      @return a view of the specified range within this list&#10;      @throws IndexOutOfBoundsException for an illegal endpoint index value&#10;              ({@code fromIndex &lt; 0 || toIndex &gt; size ||&#10;              fromIndex &gt; toIndex})" />
      <item value="    This method eliminates the need for explicit range operations (of&#10;      the sort that commonly exist for arrays).  Any operation that expects&#10;      a list can be used as a range operation by passing a subList view&#10;      instead of a whole list.  For example, the following idiom&#10;      removes a range of elements from a list:&#10;      &lt;pre&gt;{@code&#10;           list.subList(from, to).clear();&#10;      }&lt;pre&gt;&#10;      Similar idioms may be constructed for {@code indexOf} and&#10;      {@code lastIndexOf}, and all of the algorithms in the&#10;      {@code Collections} class can be applied to a subList.&lt;p&gt;&#10;     &#10;      The semantics of the list returned by this method become undefined if&#10;      the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;i&gt; in&#10;      any way other than via the returned list.  (Structural modifications are&#10;      those that change the size of this list, or otherwise perturb it in such&#10;      a fashion that iterations in progress may yield incorrect results.)" />
      <item value="      Returns a view of the portion of this list between the specified&#10;      {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If&#10;      {@code fromIndex} and {@code toIndex} are equal, the returned list is&#10;      empty.)  The returned list is backed by this list, so non-structural&#10;      changes in the returned list are reflected in this list, and vice-versa.&#10;      The returned list supports all of the optional list operations supported&#10;      by this list.&lt;p&gt;&#10;     " />
      <item value="probe Manager" />
      <item value="      &lt;p&gt;The {@code identity} value must be an identity for the accumulator&#10;      function. This means that for all {@code t},&#10;      {@code accumulator.apply(identity, t)} is equal to {@code t}.&#10;      The {@code accumulator} function must be an&#10;      &lt;a href=&quot;package-summary.htmlAssociativity&quot;&gt;associative&lt;a&gt; function.&#10;     &#10;      &lt;p&gt;This is a &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;terminal&#10;      operation&lt;a&gt;.&#10;     &#10;      @apiNote Sum, min, max, average, and string concatenation are all special&#10;      cases of reduction. Summing a stream of numbers can be expressed as:&#10;     &#10;      &lt;pre&gt;{@code&#10;          Integer sum = integers.reduce(0, (a, b) -&gt; a+b);&#10;      }&lt;pre&gt;&#10;     " />
      <item value="      Performs a &lt;a href=&quot;package-summary.htmlReduction&quot;&gt;reduction&lt;a&gt; on the&#10;      elements of this stream, using the provided identity value and an&#10;      &lt;a href=&quot;package-summary.htmlAssociativity&quot;&gt;associative&lt;a&gt;&#10;      accumulation function, and returns the reduced value.  This is equivalent&#10;      to:&#10;      &lt;pre&gt;{@code&#10;          T result = identity;&#10;          for (T element : this stream)&#10;              result = accumulator.apply(result, element)&#10;          return result;&#10;      }&lt;pre&gt;&#10;     &#10;      but is not constrained to execute sequentially." />
      <item value="&#9;  This will be used as the bean name instead of name if present, but will not be used&#10;&#9;  as a service id.&#10;&#9;  @return bean name instead of name if present" />
      <item value="成功" />
      <item value="处理中" />
      <item value="constant&#10;" />
      <item value="constan [constan]&#10;" />
      <item value="常量&#10;" />
      <item value="ih" />
      <item value="constant" />
      <item value="Path" />
      <item value="Statistics" />
      <item value="Probe" />
      <item value="statistics" />
      <item value="转换器&#10;" />
      <item value="Cfg Edge Probe Convertor" />
      <item value="Porbe" />
      <item value="Convertor" />
      <item value="convertor" />
      <item value="convertor&#10;" />
      <item value="maximum number of fractional digits accepted for this number" />
      <item value="maximum number of integral digits accepted for this number" />
      <item value="Nacos Registration" />
      <item value="并行" />
      <item value="prepare Middle Table" />
      <item value="create" />
      <item value="creat" />
      <item value="Table" />
      <item value="Origin" />
      <item value="relative" />
      <item value="fixed Rate" />
      <item value="Ratio&#9;" />
      <item value="环比同比&#10;" />
      <item value="环比同比&#10;&#10;" />
      <item value="环比&#10;" />
      <item value="环比" />
      <item value="hr" />
      <item value="环比指标" />
      <item value="transform" />
      <item value="export" />
      <item value="  Annotation used at the field or methodconstructor parameter level&#10;  that indicates a default value expression for the annotated element.&#10; &#10;  &lt;p&gt;Typically used for expression-driven or property-driven dependency injection.&#10;  Also supported for dynamic resolution of handler method arguments &amp;mdash; for&#10;  example, in Spring MVC.&#10; &#10;  &lt;p&gt;A common use case is to inject values using&#10;  &lt;code&gt;{systemProperties.myProp}&lt;code&gt; style SpEL (Spring Expression Language)&#10;  expressions. Alternatively, values may be injected using&#10;  &lt;code&gt;{my.app.myProp}&lt;code&gt; style property placeholders.&#10; &#10;  &lt;p&gt;Note that actual processing of the {@code @Value} annotation is performed&#10;  by a {@link org.springframework.beans.factory.config.BeanPostProcessor&#10;  BeanPostProcessor} which in turn means that you &lt;em&gt;cannot&lt;em&gt; use&#10;  {@code @Value} within&#10;  {@link org.springframework.beans.factory.config.BeanPostProcessor&#10;  BeanPostProcessor} or&#10;  {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}&#10;  types. Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor}&#10;  class (which, by default, checks for the presence of this annotation)." />
      <item value="send Trap" />
      <item value="indicators" />
      <item value="event period" />
      <item value="  Marker annotation that indicates that the logical property that&#10;  the accessor (field, gettersetter method or Creator parameter&#10;  [of {@link JsonCreator}-annotated constructor or factory method])&#10;  is to be ignored by introspection-based&#10;  serialization and deserialization functionality.&#10; &lt;p&gt;&#10;  Annotation only needs to be added to one of the accessors (often&#10;  getter method, but may be setter, field or creator parameter),&#10;  if the complete removal of the property is desired.&#10;  However: if only particular accessor is to be ignored (for example,&#10;  when ignoring one of potentially conflicting setter methods),&#10;  this can be done by annotating other not-to-be-ignored accessors&#10;  with {@link JsonProperty} (or its equivalents). This is considered&#10;  so-called &quot;split property&quot; case and allows definitions of&#10;  &quot;read-only&quot; (read from input into POJO) and &quot;write-only&quot; (write&#10;  in output but ignore on output)&#10; &lt;br&gt;&#10;  NOTE! As Jackson 2.6, there is a new and improved way to define&#10;  `read-only` and `write-only` properties, using&#10;  {@link JsonPropertyaccess()} annotation: this is recommended over&#10;  use of separate &lt;code&gt;JsonIgnore&lt;code&gt; and {@link JsonProperty}&#10;  annotations.&#10; &lt;p&gt;&#10;  For example, a &quot;getter&quot; method that would otherwise denote&#10;  a property (like, say, &quot;getValue&quot; to suggest property &quot;value&quot;)&#10;  to serialize, would be ignored and no such property would&#10;  be output unless another annotation defines alternative method to use.&#10; &lt;p&gt;&#10;  When ignoring the whole property, the default behavior if encountering&#10;  such property in input is to ignore it without exception; but if there&#10;  is a {@link JsonAnySetter} it will be called instead. Either way,&#10;  no exception will be thrown.&#10; &lt;p&gt;&#10;  Annotation is usually used just a like a marker annotation, that&#10;  is, without explicitly defining 'value' argument (which defaults&#10;  to &lt;code&gt;true&lt;code&gt;): but argument can be explicitly defined.&#10;  This can be done to override an existing `JsonIgnore` by explicitly&#10;  defining one with 'false' argument: either in a sub-class, or by&#10;  using &quot;mix-in annotations&quot;." />
      <item value="A string composed of this string repeated&#10;               {@code count} times or the empty string if this&#10;               string is empty or count is zero" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1675756113550" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="autoSelectionMode" value="EXCLUSIVE" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>