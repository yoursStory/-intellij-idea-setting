<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="592" />
    <option name="newTranslationDialogX" value="2783" />
    <option name="newTranslationDialogY" value="225" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="flip" />
      <item value="mulit Ids" />
      <item value="Mulit" />
      <item value="get Mulit Dataset Vo" />
      <item value="Muli" />
      <item value="      Returns an {@code UnmodifiableList} of the CPU's physical processors. The&#10;      list will be sorted in order of increasing core ID.&#10;     &#10;      @return An {@code UnmodifiabeList} of physical processors." />
      <item value="the number of logical processors, which corresponds to the number&#10;                 of lines to read from the file." />
      <item value="caveats" />
      <item value="caveate" />
      <item value="cave" />
      <item value="interchangeable" />
      <item value="interchange" />
      <item value="inter" />
      <item value="counterpart" />
      <item value="counterparts" />
      <item value="c" />
      <item value="several" />
      <item value="se" />
      <item value="see" />
      <item value="particular" />
      <item value="parti" />
      <item value="https://github.com/kohlschutter/junixsocket.git" />
      <item value="staging" />
      <item value="use-staging" />
      <item value="datagrams" />
      <item value=" Additionally, you can build and run junixsocket natively on IBM zOS (experimental).&#10; Supports all Java versions since Java 8&#10; Supports both the Java Socket API and NIO " />
      <item value=" Comes with pre-built native libraries for most operating systems and platforms, including&#10;  macOS, Linux, Windows, Solaris, FreeBSD, NetBSD, OpenBSD, DragonFlyBSD, AIX, IBM i." />
      <item value=" junixsocket is the most complete implementation of AF_UNIX sockets for the Java ecosystem.&#10; Supports other socket types, such as TIPC (on Linux) and VSOCK (on Linux, and certain macOS VMs), as well!" />
      <item value="Linux Sensors" />
      <item value="      Number of pages written to pagingswap file(s) to free up space in physical&#10;      memory. Pages are written back to disk only if they are changed in physical&#10;      memory, so they are likely to hold data, not code. A high rate of pages&#10;      output might indicate a memory shortage. The operating system writes more&#10;      pages back to disk to free up space when physical memory is in short supply." />
      <item value="      Number of pages read from pagingswap file(s) to resolve hard page faults.&#10;      (Hard page faults occur when a process requires code or data that is not in&#10;      its working set or elsewhere in physical memory, and must be retrieved from&#10;      disk.) This property was designed as a primary indicator of the kinds of&#10;      faults that cause system-wide delays. It includes pages retrieved to satisfy&#10;      faults in the file system cache (usually requested by applications) and in&#10;      non-cached mapped memory files." />
      <item value="      The memory currently committed by the system, in bytes. Also called the&#10;      Commit Total. This is generally equal to the sum of the bytes used of&#10;      physical memory and pagingswap file(s).&#10;      &lt;p&gt;&#10;      On Windows, committing pages changes this value immediately; however, the&#10;      physical memory is not charged until the pages are accessed, so this value&#10;      may exceed the sum of used physical and pagingswap file memory.&#10;     &#10;      @return Swap used in bytes" />
      <item value="extending" />
      <item value="      The maximum memory that can be committed by the system without extending the&#10;      paging file(s), in bytes. Also called the Commit Limit. If the pagingswap&#10;      file can be extended, this is a soft limit. This is generally equal to the&#10;      sum of the sizes of physical memory and pagingswap file(s)." />
      <item value="      The maximum memory that can be committed by the system without extending the&#10;      paging file(s), in bytes. Also called the Commit Limit. If the pagingswap&#10;      file can be extended, this is a soft limit. This is generally equal to the&#10;      sum of the sizes of physical memory and pagingswap file(s).&#10;      &lt;p&gt;&#10;      On Linux, represents the total amount of memory currently available to be&#10;      allocated on the system based on the overcommit ratio, identified as&#10;      {@code CommitLimit}. This may be higher or lower than the total size of&#10;      physical and swap memory depending on system configuration.&#10;     " />
      <item value="      The current memory committed to the pagingswap file(s), in bytes&#10;     &#10;      @return Swap used in bytes" />
      <item value="      The current size of the pagingswap file(s), in bytes. If the pagingswap&#10;      file can be extended, this is a soft limit." />
      <item value="an array of the system load averages for 1, 5, and 15 minutes with&#10;              the size of the array specified by nelem; or negative values if not&#10;              available." />
      <item value="      @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value=" @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value="      Get System-wide CPU Load tick counters. Returns an array with eight elements&#10;      representing milliseconds spent in User (0), Nice (1), System (2), Idle (3),&#10;      IOwait (4), Hardware interrupts (IRQ) (5), Software interruptsDPC (SoftIRQ)&#10;      (6), or Steal (7) states. Use&#10;      {@link oshi.hardware.CentralProcessor.TickTypegetIndex()} to retrieve the&#10;      appropriate index. By measuring the difference between ticks across a time&#10;      interval, CPU load over that interval may be calculated.&#10;      &lt;p&gt;&#10;      Note that while tick counters are in units of milliseconds, they may advance&#10;      in larger increments along with (platform dependent) clock ticks. For&#10;      example, by default Windows clock ticks are 164 of a second (about 15 or 16&#10;      milliseconds) and Linux ticks are distribution and configuration dependent&#10;      but usually 1100 of a second (10 milliseconds).&#10;      &lt;p&gt;&#10;      Nice and IOWait information is not available on Windows, and IOwait and IRQ&#10;      information is not available on macOS, so these ticks will always be zero.&#10;      &lt;p&gt;&#10;      To calculate overall Idle time using this method, include both Idle and&#10;      IOWait ticks. Similarly, IRQ, SoftIRQ, and Steal ticks should be added to the&#10;      System value to get the total. System ticks also include time executing other&#10;      virtual hosts (steal).&#10;     &#10;      @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value="      Returns the &quot;recent cpu usage&quot; for the whole system by counting ticks from&#10;      {@link getSystemCpuLoadTicks()} between the user-provided value from a&#10;      previous call." />
      <item value="      Returns an {@code UnmodifiableList} of the CPU's logical processors. The list&#10;      will be sorted in order of increasing NUMA node number, and then processor&#10;      number. This order is consistent with other methods providing per-processor&#10;      results." />
      <item value="Maximum frequeny (in Hz), of the logical processors on this CPU." />
      <item value="          Time that the CPU or CPUs were idle and the system did not have an&#10;          outstanding disk IO request." />
      <item value="          CPU utilization that occurred while executing at the user level with nice&#10;          priority." />
      <item value="processor Number" />
      <item value="physical Processor Number" />
      <item value="      A class representing a Logical Processor and its replationship to physical&#10;      processors, physical packages, and logical groupings such as NUMA Nodes and&#10;      Processor groups, useful for identifying processor topology." />
      <item value="efficiency" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1672046794921" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>