<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="2703" />
    <option name="newTranslationDialogY" value="454" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Linux Sensors" />
      <item value="      Number of pages written to pagingswap file(s) to free up space in physical&#10;      memory. Pages are written back to disk only if they are changed in physical&#10;      memory, so they are likely to hold data, not code. A high rate of pages&#10;      output might indicate a memory shortage. The operating system writes more&#10;      pages back to disk to free up space when physical memory is in short supply." />
      <item value="      Number of pages read from pagingswap file(s) to resolve hard page faults.&#10;      (Hard page faults occur when a process requires code or data that is not in&#10;      its working set or elsewhere in physical memory, and must be retrieved from&#10;      disk.) This property was designed as a primary indicator of the kinds of&#10;      faults that cause system-wide delays. It includes pages retrieved to satisfy&#10;      faults in the file system cache (usually requested by applications) and in&#10;      non-cached mapped memory files." />
      <item value="      The memory currently committed by the system, in bytes. Also called the&#10;      Commit Total. This is generally equal to the sum of the bytes used of&#10;      physical memory and pagingswap file(s).&#10;      &lt;p&gt;&#10;      On Windows, committing pages changes this value immediately; however, the&#10;      physical memory is not charged until the pages are accessed, so this value&#10;      may exceed the sum of used physical and pagingswap file memory.&#10;     &#10;      @return Swap used in bytes" />
      <item value="extending" />
      <item value="      The maximum memory that can be committed by the system without extending the&#10;      paging file(s), in bytes. Also called the Commit Limit. If the pagingswap&#10;      file can be extended, this is a soft limit. This is generally equal to the&#10;      sum of the sizes of physical memory and pagingswap file(s)." />
      <item value="      The maximum memory that can be committed by the system without extending the&#10;      paging file(s), in bytes. Also called the Commit Limit. If the pagingswap&#10;      file can be extended, this is a soft limit. This is generally equal to the&#10;      sum of the sizes of physical memory and pagingswap file(s).&#10;      &lt;p&gt;&#10;      On Linux, represents the total amount of memory currently available to be&#10;      allocated on the system based on the overcommit ratio, identified as&#10;      {@code CommitLimit}. This may be higher or lower than the total size of&#10;      physical and swap memory depending on system configuration.&#10;     " />
      <item value="      The current memory committed to the pagingswap file(s), in bytes&#10;     &#10;      @return Swap used in bytes" />
      <item value="      The current size of the pagingswap file(s), in bytes. If the pagingswap&#10;      file can be extended, this is a soft limit." />
      <item value="an array of the system load averages for 1, 5, and 15 minutes with&#10;              the size of the array specified by nelem; or negative values if not&#10;              available." />
      <item value="      @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value=" @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value="      Get System-wide CPU Load tick counters. Returns an array with eight elements&#10;      representing milliseconds spent in User (0), Nice (1), System (2), Idle (3),&#10;      IOwait (4), Hardware interrupts (IRQ) (5), Software interruptsDPC (SoftIRQ)&#10;      (6), or Steal (7) states. Use&#10;      {@link oshi.hardware.CentralProcessor.TickTypegetIndex()} to retrieve the&#10;      appropriate index. By measuring the difference between ticks across a time&#10;      interval, CPU load over that interval may be calculated.&#10;      &lt;p&gt;&#10;      Note that while tick counters are in units of milliseconds, they may advance&#10;      in larger increments along with (platform dependent) clock ticks. For&#10;      example, by default Windows clock ticks are 164 of a second (about 15 or 16&#10;      milliseconds) and Linux ticks are distribution and configuration dependent&#10;      but usually 1100 of a second (10 milliseconds).&#10;      &lt;p&gt;&#10;      Nice and IOWait information is not available on Windows, and IOwait and IRQ&#10;      information is not available on macOS, so these ticks will always be zero.&#10;      &lt;p&gt;&#10;      To calculate overall Idle time using this method, include both Idle and&#10;      IOWait ticks. Similarly, IRQ, SoftIRQ, and Steal ticks should be added to the&#10;      System value to get the total. System ticks also include time executing other&#10;      virtual hosts (steal).&#10;     &#10;      @return An array of 8 long values representing time spent in User, Nice,&#10;              System, Idle, IOwait, IRQ, SoftIRQ, and Steal states." />
      <item value="      Returns the &quot;recent cpu usage&quot; for the whole system by counting ticks from&#10;      {@link getSystemCpuLoadTicks()} between the user-provided value from a&#10;      previous call." />
      <item value="      Returns an {@code UnmodifiableList} of the CPU's logical processors. The list&#10;      will be sorted in order of increasing NUMA node number, and then processor&#10;      number. This order is consistent with other methods providing per-processor&#10;      results." />
      <item value="Maximum frequeny (in Hz), of the logical processors on this CPU." />
      <item value="          Time that the CPU or CPUs were idle and the system did not have an&#10;          outstanding disk IO request." />
      <item value="          CPU utilization that occurred while executing at the user level with nice&#10;          priority." />
      <item value="processor Number" />
      <item value="physical Processor Number" />
      <item value="      A class representing a Logical Processor and its replationship to physical&#10;      processors, physical packages, and logical groupings such as NUMA Nodes and&#10;      Processor groups, useful for identifying processor topology." />
      <item value="efficiency" />
      <item value="physical Package Number" />
      <item value="     A class representing a Physical Processor (a core) providing per-core&#10;      statistics that may vary, particularly in hybridmodular processors." />
      <item value="cpu Model" />
      <item value="cpu Stepping" />
      <item value="processor ID" />
      <item value="cpu Identifier" />
      <item value="cpu Vendor Freq" />
      <item value="cpu Family" />
      <item value="cpu Vendor" />
      <item value="      A class encapsulating ghe CPU's identifier strings ,including name, vendor,&#10;      stepping, model, and family information (also called the signature of a CPU)" />
      <item value="Processor Identifier" />
      <item value="  The presence of this annotation indicates that the author believes the class&#10;  to be immutable and hence inherently thread-safe. An immutable class is one&#10;  where the state of an instance cannot be &lt;i&gt;seen&lt;i&gt; to change. As a result&#10;  &lt;ul&gt;&#10;  &lt;li&gt;All public fields must be {@code final}&lt;li&gt;&#10;  &lt;li&gt;All public final reference fields are either {@code null} or refer to&#10;  other immutable objects&lt;li&gt;&#10;  &lt;li&gt;Constructors and methods do not publish references to any potentially&#10;  mutable internal state.&lt;li&gt;&#10;  &lt;ul&gt;&#10;  Performance optimization may mean that instances of an immutable class may&#10;  have mutable internal state. The critical point is that callers cannot tell&#10;  the difference. For example {@link String} is an immutable class, despite&#10;  having an internal int that is non-final but used as a cache for&#10;  {@link StringhashCode()}.&#10;  &lt;p&gt;&#10;  Immutable objects are inherently thread-safe; they may be passed between&#10;  threads or published without synchronization.&#10;  &lt;p&gt;&#10;  This annotation is intended for internal use in OSHI as a temporary&#10;  workaround until it is available in {@code jakarta.annotations}." />
      <item value="Immutable" />
      <item value="  This class represents the entire Central Processing Unit (CPU) of a computer&#10;  system, which may contain one or more physical packages (sockets), one or&#10;  more physical processors (cores), and one or more logical processors (what&#10;  the Operating System sees, which may include hyperthreaded cores.)" />
      <item value="Major" />
      <item value="The unique partition id" />
      <item value="The time spent reading or writing, in milliseconds." />
      <item value="the transfer time" />
      <item value="      The length of the disk queue (IO's in progress). Includes IO requests that&#10;      have been issued to the device driver but have not yet completed. Not&#10;      supported on macOS.&#10;     " />
      <item value="      The length of the disk queue (IO's in progress). Includes IO requests that&#10;      have been issued to the device driver but have not yet completed. Not&#10;      supported on macOS.&#10;     &#10;      @return the current disk queue length" />
      <item value="The number of bytes read from the disk" />
      <item value="The number of reads from the disk" />
      <item value="         The parsing implementation in ParseUtil requires these to be declared&#10;         in increasing order. Use 0-ordered index here" />
      <item value="compute Disk Stats" />
      <item value="model" />
      <item value="serial" />
      <item value="The disk model" />
      <item value="      Make a best effort to update all the statistics about the drive without&#10;      needing to recreate the drive list. This method provides for more frequent&#10;      periodic updates of individual drive statistics but may be less efficient to&#10;      use if updating all drives. It will not detect if a removable drive has been&#10;      removed and replaced by a different drive in between method calls." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1670822899598" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>