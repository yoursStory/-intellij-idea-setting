<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="2703" />
    <option name="newTranslationDialogY" value="454" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="combination" />
      <item value="  {@link org.springframework.context.MessageSource} implementation that&#10;  accesses resource bundles using specified basenames. This class relies&#10;  on the underlying JDK's {@link java.util.ResourceBundle} implementation,&#10;  in combination with the JDK's standard message parsing provided by&#10;  {@link java.text.MessageFormat}.&#10; &#10;  &lt;p&gt;This MessageSource caches both the accessed ResourceBundle instances and&#10;  the generated MessageFormats for each message. It also implements rendering of&#10;  no-arg messages without MessageFormat, as supported by the AbstractMessageSource&#10;  base class. The caching provided by this MessageSource is significantly faster&#10;  than the built-in caching of the {@code java.util.ResourceBundle} class.&#10; &#10;  &lt;p&gt;The basenames follow {@link java.util.ResourceBundle} conventions: essentially,&#10;  a fully-qualified classpath location. If it doesn't contain a package qualifier&#10;  (such as {@code org.mypackage}), it will be resolved from the classpath root.&#10;  Note that the JDK's standard ResourceBundle treats dots as package separators:&#10;  This means that &quot;test.theme&quot; is effectively equivalent to &quot;testtheme&quot;.&#10; &#10;  &lt;p&gt;On the classpath, bundle resources will be read with the locally configured&#10;  {@link setDefaultEncoding encoding}: by default, ISO-8859-1; consider switching&#10;  this to UTF-8, or to {@code null} for the platform default encoding. On the JDK 9+&#10;  module path where locally provided {@code ResourceBundle.Control} handles are not&#10;  supported, this MessageSource always falls back to {@link ResourceBundlegetBundle}&#10;  retrieval with the platform default encoding: UTF-8 with a ISO-8859-1 fallback on&#10;  JDK 9+ (configurable through the &quot;java.util.PropertyResourceBundle.encoding&quot; system&#10;  property). Note that {@link loadBundle(Reader)}{@link loadBundle(InputStream)}&#10;  won't be called in this case either, effectively ignoring overrides in subclasses.&#10;  Consider implementing a JDK 9 {@code java.util.spi.ResourceBundleProvider} instead." />
      <item value="Resource Bundle" />
      <item value="  Empty {@link MessageSource} that delegates all calls to the parent MessageSource.&#10;  If no parent is available, it simply won't resolve any message.&#10; &#10;  &lt;p&gt;Used as placeholder by AbstractApplicationContext, if the context doesn't&#10;  define its own MessageSource. Not intended for direct use in applications." />
      <item value="Delegating Message Source" />
      <item value="&#9;  Try to resolve the message using all the attributes contained within the&#10;&#9;  {@code MessageSourceResolvable} argument that was passed in.&#10;&#9;  &lt;p&gt;NOTE: We must throw a {@code NoSuchMessageException} on this method&#10;&#9;  since at the time of calling this method we aren't able to determine if the&#10;&#9;  {@code defaultMessage} property of the resolvable is {@code null} or not.&#10;&#9;  @param resolvable the value object storing attributes required to resolve a message&#10;&#9;  (may include a default message)&#10;&#9;  @param locale the locale in which to do the lookup&#10;&#9;  @return the resolved message (never {@code null} since even a&#10;&#9;  {@code MessageSourceResolvable}-provided default message needs to be non-null)&#10;&#9;  @throws NoSuchMessageException if no corresponding message was found&#10;&#9;  (and no default message was provided by the {@code MessageSourceResolvable})" />
      <item value="&#9;  Try to resolve the message. Return default message if no message was found.&#10;&#9;  @param code the message code to look up, e.g. 'calculator.noRateSet'.&#10;&#9;  MessageSource users are encouraged to base message names on qualified class&#10;&#9;  or package names, avoiding potential conflicts and ensuring maximum clarity.&#10;&#9;  @param args an array of arguments that will be filled in for params within&#10;&#9;  the message (params look like &quot;{0}&quot;, &quot;{1,date}&quot;, &quot;{2,time}&quot; within a message),&#10;&#9;  or {@code null} if none&#10;&#9;  @param defaultMessage a default message to return if the lookup fails&#10;&#9;  @param locale the locale in which to do the lookup&#10;&#9;  @return the resolved message if the lookup was successful, otherwise&#10;&#9;  the default message passed as a parameter (which may be {@code null})" />
      <item value="  &lt;p&gt;Spring provides two out-of-the-box implementations for production:&#10;  &lt;ul&gt;&#10;  &lt;li&gt;{@link org.springframework.context.support.ResourceBundleMessageSource}: built&#10;  on top of the standard {@link java.util.ResourceBundle}, sharing its limitations.&#10;  &lt;li&gt;{@link org.springframework.context.support.ReloadableResourceBundleMessageSource}:&#10;  highly configurable, in particular with respect to reloading message definitions.&#10;  &lt;ul&gt;" />
      <item value="  Strategy interface for resolving messages, with support for the parameterization&#10;  and internationalization of such messages." />
      <item value="&#9;  Used to dereference a {@link FactoryBean} instance and distinguish it from&#10;&#9;  beans &lt;i&gt;created&lt;i&gt; by the FactoryBean. For example, if the bean named&#10;&#9;  {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject}&#10;&#9;  will return the factory, not the instance returned by the factory." />
      <item value="&#9;  Replace the property source with the given name with the given property source object.&#10;&#9;  @param name the name of the property source to find and replace&#10;&#9;  @param propertySource the replacement property source&#10;&#9;  @throws IllegalArgumentException if no property source with the given name is present" />
      <item value="characteristics" />
      <item value="      Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.htmlbinding&quot;&gt;late-binding&lt;a&gt;&lt;em&gt;&#10;      and &lt;em&gt;fail-fast&lt;em&gt; {@link Spliterator} over the elements in this&#10;      list.&#10;     &#10;      &lt;p&gt;The {@code Spliterator} reports {@link SpliteratorSIZED},&#10;      {@link SpliteratorSUBSIZED}, and {@link SpliteratorORDERED}.&#10;      Overriding implementations should document the reporting of additional&#10;      characteristic values." />
      <item value="spliter" />
      <item value="spliterator" />
      <item value="Spliterator" />
      <item value="      The default implementation should usually be overridden.  The&#10;      spliterator returned by the default implementation has poor splitting&#10;      capabilities, is unsized, and does not report any spliterator&#10;      characteristics. Implementing classes can nearly always provide a&#10;      better implementation." />
      <item value="Mutable Property Sources" />
      <item value="  &lt;h3&gt;Registration&lt;h3&gt;&#10;  &lt;p&gt;An {@code ApplicationContext} auto-detects {@code BeanFactoryPostProcessor}&#10;  beans in its bean definitions and applies them before any other beans get created.&#10;  A {@code BeanFactoryPostProcessor} may also be registered programmatically&#10;  with a {@code ConfigurableApplicationContext}." />
      <item value="  &lt;p&gt;A {@code BeanFactoryPostProcessor} may interact with and modify bean&#10;  definitions, but never bean instances. Doing so may cause premature bean&#10;  instantiation, violating the container and causing unintended side-effects.&#10;  If bean instance interaction is required, consider implementing&#10;  {@link BeanPostProcessor} instead.&#10; " />
      <item value="  &lt;p&gt;Useful for custom config files targeted at system administrators that&#10;  override bean properties configured in the application context. See&#10;  {@link PropertyResourceConfigurer} and its concrete implementations for&#10;  out-of-the-box solutions that address such configuration needs.&#10; " />
      <item value="  Factory hook that allows for custom modification of an application context's&#10;  bean definitions, adapting the bean property values of the context's underlying&#10;  bean factory." />
      <item value="&#9;  Resolve {...} placeholders in the given text, replacing them with corresponding&#10;&#9;  property values as resolved by {@link getProperty}. Unresolvable placeholders with&#10;&#9;  no default value are ignored and passed through unchanged.&#10;&#9;  @param text the String to resolve&#10;&#9;  @return the resolved String (never {@code null})&#10;&#9;  @throws IllegalArgumentException if given text is {@code null}" />
      <item value="synthetic" />
      <item value="Flushable" />
      <item value="  An interpreter for printf-style format strings.  This class provides support&#10;  for layout justification and alignment, common formats for numeric, string,&#10;  and datetime data, and locale-specific output.  Common Java types such as&#10;  {@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}&#10;  are supported.  Limited formatting customization for arbitrary user types is&#10;  provided through the {@link Formattable} interface." />
      <item value="tagging" />
      <item value="resolve Embedded Value" />
      <item value="combine" />
      <item value="Injected" />
      <item value="impacting" />
      <item value="  &lt;p&gt;Implemented interfaces are satisfied in the order in which they are&#10;  mentioned above." />
      <item value="  Factory hook that allows for custom modification of new bean instances &amp;mdash;&#10;  for example, checking for marker interfaces or wrapping beans with proxies.&#10; &#10;  &lt;p&gt;Typically, post-processors that populate beans via marker interfaces&#10;  or the like will implement {@link postProcessBeforeInitialization},&#10;  while post-processors that wrap beans with proxies will normally&#10;  implement {@link postProcessAfterInitialization}.&#10; &#10;  &lt;h3&gt;Registration&lt;h3&gt;&#10;  &lt;p&gt;An {@code ApplicationContext} can autodetect {@code BeanPostProcessor} beans&#10;  in its bean definitions and apply those post-processors to any beans subsequently&#10;  created. A plain {@code BeanFactory} allows for programmatic registration of&#10;  post-processors, applying them to all beans created through the bean factory." />
      <item value="  A marker superinterface indicating that a bean is eligible to be notified by the&#10;  Spring container of a particular framework object through a callback-style method.&#10;  The actual method signature is determined by individual subinterfaces but should&#10;  typically consist of just one void-returning method that accepts a single argument.&#10; &#10;  &lt;p&gt;Note that merely implementing {@link Aware} provides no default functionality.&#10;  Rather, processing must be done explicitly, for example in a&#10;  {@link org.springframework.beans.factory.config.BeanPostProcessor}.&#10;  Refer to {@link org.springframework.context.support.ApplicationContextAwareProcessor}&#10;  for an example of processing specific {@code Aware} interface callbacks." />
      <item value="Inject" />
      <item value="      Useful constant for the root locale.  The root locale is the locale whose&#10;      language, country, and variant are empty (&quot;&quot;) strings.  This is regarded&#10;      as the base locale of all locales, and is used as the languagecountry&#10;      neutral locale for the locale sensitive operations." />
      <item value="Restrict" />
      <item value="Addiation" />
      <item value="set Max Inactive Interval" />
      <item value="  The annotation type {@code java.lang.annotation.Repeatable} is&#10;  used to indicate that the annotation type whose declaration it&#10;  (meta-)annotates is &lt;em&gt;repeatable&lt;em&gt;. The value of&#10;  {@code @Repeatable} indicates the &lt;em&gt;containing annotation&#10;  type&lt;em&gt; for the repeatable annotation type." />
      <item value="  The annotation type {@code java.lang.annotation.Repeatable} is&#10;  used to indicate that the annotation type whose declaration it&#10;  (meta-)annotates is &lt;em&gt;repeatable&lt;em&gt;. The value of&#10;  {@code @Repeatable} indicates the &lt;em&gt;containing annotation&#10;  type&lt;em&gt; for the repeatable annotation type.&#10; &#10;  @since 1.8&#10;  @jls 9.6.3 Repeatable Annotation Types&#10;  @jls 9.7.5 Multiple Annotations of the Same Type" />
      <item value="check Exceed" />
      <item value="is Assignable" />
      <item value="      Determines if the specified {@code Class} object represents a&#10;      primitive type.&#10;     &#10;      &lt;p&gt; There are nine predefined {@code Class} objects to represent&#10;      the eight primitive types and void.  These are created by the Java&#10;      Virtual Machine, and have the same names as the primitive types that&#10;      they represent, namely {@code boolean}, {@code byte},&#10;      {@code char}, {@code short}, {@code int},&#10;      {@code long}, {@code float}, and {@code double}.&#10;     &#10;      &lt;p&gt; These objects may only be accessed via the following public static&#10;      final variables, and are the only {@code Class} objects for which&#10;      this method returns {@code true}." />
      <item value="true if and only if this class represents a primitive type" />
      <item value="is Primitive" />
      <item value="    &lt;p&gt;Checks if one {@code Class} can be assigned to a variable of&#10;      another {@code Class}.&lt;p&gt;&#10;     &#10;      &lt;p&gt;Unlike the {@link ClassisAssignableFrom(java.lang.Class)} method,&#10;      this method takes into account widenings of primitive classes and&#10;      {@code null}s.&lt;p&gt;&#10;     &#10;      &lt;p&gt;Primitive widenings allow an int to be assigned to a long, float or&#10;      double. This method returns the correct result for these cases.&lt;p&gt;&#10;     &#10;      &lt;p&gt;{@code Null} may be assigned to any reference type. This method&#10;      will return {@code true} if {@code null} is passed in and the&#10;      toClass is non-primitive.&lt;p&gt;&#10;     &#10;      &lt;p&gt;Specifically, this method tests whether the type represented by the&#10;      specified {@code Class} parameter can be converted to the type&#10;      represented by this {@code Class} object via an identity conversion&#10;      widening primitive or widening reference conversion. See&#10;      &lt;em&gt;&lt;a href=&quot;http:docs.oracle.comjavasespecs&quot;&gt;The Java Language Specification&lt;a&gt;&lt;em&gt;,&#10;      sections 5.1.1, 5.1.2 and 5.1.4 for details.&lt;p&gt;&#10;     &#10;      &lt;p&gt;&lt;strong&gt;Since Lang 3.0,&lt;strong&gt; this method will default behavior for&#10;      calculating assignability between primitive and wrapper types &lt;em&gt;corresponding&#10;      to the running Java version&lt;em&gt;; i.e. autoboxing will be the default&#10;      behavior in VMs running Java versions &amp;gt; 1.5.&lt;p&gt;" />
      <item value="Suffer" />
      <item value="title Suffer" />
      <item value="ALL Combine Validators" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1667186933269" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>