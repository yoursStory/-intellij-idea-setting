<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="2703" />
    <option name="newTranslationDialogY" value="454" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="component" />
      <item value="_copy Stack Trace Minus One" />
      <item value="Warning this class consists of generated code." />
      <item value="     Returns the class of the caller of the method calling this method,&#10;        ignoring frames associated with java.lang.reflect.Method.invoke()&#10;        and its implementation. " />
      <item value="  This class consists exclusively of static methods that operate on or return&#10;  method handles. They fall into several categories:&#10;  &lt;ul&gt;&#10;  &lt;li&gt;Lookup methods which help create method handles for methods and fields.&#10;  &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.&#10;  &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.&#10;  &lt;ul&gt;&#10; " />
      <item value="Predefined Scope Validator Factory Impl" />
      <item value="incubating" />
      <item value="encouraged" />
      <item value="  Marks the annotated element as incubating. The contract of incubating elements (e.g. packages, types, methods,&#10;  constants etc.) is under active development and may be incompatibly altered - or removed - in subsequent releases.&#10;  &lt;p&gt;&#10;  Usage of incubating APISPI members is encouraged (so the development team can get feedback on these new features)&#10;  but you should be prepared for updating code which is using them as needed." />
      <item value="Incubating" />
      <item value="  Provides Hibernate Validator extensions to {@link ValidatorFactory} in the context of a predefined scope." />
      <item value="visible side effect" />
      <item value="      &lt;p&gt;Note that unlike the {@link java.io.Closeableclose close}&#10;      method of {@link java.io.Closeable}, this {@code close} method&#10;      is &lt;em&gt;not&lt;em&gt; required to be idempotent.  In other words,&#10;      calling this {@code close} method more than once may have some&#10;      visible side effect, unlike {@code Closeable.close} which is&#10;      required to have no effect if called more than once." />
      <item value="idempotent" />
      <item value="     Closes this resource, relinquishing any underlying resources.&#10;      This method is invoked automatically on objects managed by the&#10;      {@code try}-with-resources statement.&#10;     &#10;      &lt;p&gt;While this interface method is declared to throw {@code&#10;      Exception}, implementers are &lt;em&gt;strongly&lt;em&gt; encouraged to&#10;      declare concrete implementations of the {@code close} method to&#10;      throw more specific exceptions, or to throw no exception at all&#10;      if the close operation cannot fail.&#10;     &#10;      &lt;p&gt; Cases where the close operation may fail require careful&#10;      attention by implementers. It is strongly advised to relinquish&#10;      the underlying resources and to internally &lt;em&gt;mark&lt;em&gt; the&#10;      resource as closed, prior to throwing the exception. The {@code&#10;      close} method is unlikely to be invoked more than once and so&#10;      this ensures that the resources are released in a timely manner.&#10;      Furthermore it reduces problems that could arise when the resource&#10;      wraps, or is wrapped, by another resource.&#10;     &#10;      &lt;p&gt;&lt;em&gt;Implementers of this interface are also strongly advised&#10;      to not have the {@code close} method throw {@link&#10;      InterruptedException}.&lt;em&gt;&#10;     &#10;      This exception interacts with a thread's interrupted status,&#10;      and runtime misbehavior is likely to occur if an {@code&#10;      InterruptedException} is {@linkplain ThrowableaddSuppressed&#10;      suppressed}.&#10;     &#10;      More generally, if it would cause problems for an&#10;      exception to be suppressed, the {@code AutoCloseable.close}&#10;      method should not throw it.&#10;     &#10;      &lt;p&gt;Note that unlike the {@link java.io.Closeableclose close}&#10;      method of {@link java.io.Closeable}, this {@code close} method&#10;      is &lt;em&gt;not&lt;em&gt; required to be idempotent.  In other words,&#10;      calling this {@code close} method more than once may have some&#10;      visible side effect, unlike {@code Closeable.close} which is&#10;      required to have no effect if called more than once.&#10;     &#10;      However, implementers of this interface are strongly encouraged&#10;      to make their {@code close} methods idempotent." />
      <item value="relinquishing" />
      <item value="  &lt;p&gt;It is possible, and in fact common, for a base class to&#10;  implement AutoCloseable even though not all of its subclasses or&#10;  instances will hold releasable resources.  For code that must operate&#10;  in complete generality, or when it is known that the {@code AutoCloseable}&#10;  instance requires resource release, it is recommended to use {@code&#10;  try}-with-resources constructions. However, when using facilities such as&#10;  {@link java.util.stream.Stream} that support both IO-based and&#10;  non-IO-based forms, {@code try}-with-resources blocks are in&#10;  general unnecessary when using non-IO-based forms." />
      <item value="  implement AutoCloseable even though not all of its subclasses or&#10;  instances will hold releasable resources.  For code that must operate&#10;  in complete generality, or when it is known that the {@code AutoCloseable}" />
      <item value="It is possible, and in fact common, for a base class to&#10;  implement AutoCloseable even though not all of its subclasses or&#10;  instances will hold releasable resources.  For code that must operate&#10;  in complete generality, or when it is known that the {@code AutoCloseable}&#10;  instance requires resource release, it is recommended to use {@code&#10;  try}-with-resources constructions. However, when using facilities such as&#10;  {@link java.util.stream.Stream} that support both IO-based and&#10;  non-IO-based forms, {@code try}-with-resources blocks are in&#10;  general unnecessary when using non-IO-based forms." />
      <item value="exhaustion" />
      <item value="avoiding" />
      <item value=" try}-with-resources block for which the object has been declared in&#10;  the resource specification header. This construction ensures prompt&#10;  release, avoiding resource exhaustion exceptions and errors that&#10;  may otherwise occur." />
      <item value="cascading" />
      <item value="IMPLICIT" />
      <item value="&#9;  If the annotation using {@code ExecutableType} is on a type (class or interface),&#10;&#9;  the behavior is equivalent to the annotation not being present." />
      <item value="agnostic" />
      <item value="ALL Combine Validators" />
      <item value="exclusions" />
      <item value="simultaneou" />
      <item value="Too many simultaneous queries" />
      <item value="simultaneous" />
      <item value="Convertor" />
      <item value="convertor" />
      <item value="parent tbl id" />
      <item value="Algorithm" />
      <item value="extAlgorithm" />
      <item value="cascade" />
      <item value="quota" />
      <item value="Column Type Convertor" />
      <item value="is Exist Updateable" />
      <item value="is Exist Configable" />
      <item value=" maximum number of fractional digits accepted for this number" />
      <item value="Digits" />
      <item value="negative" />
      <item value="statistical Size" />
      <item value="Mutation Plan" />
      <item value="combine" />
      <item value="side-effect" />
      <item value="On first setup, you may need to run ` mvn install -DskipTests`&#10;to install the local jars. This is a side-effect of multi-module maven projects" />
      <item value=" The most common stream of tokens where every token is buffered up&#10;   and tokens are filtered for a certain channel (the parser will only&#10;   see these tokens).&#10; &#10;   Even though it buffers all of the tokens, this token stream pulls tokens&#10;   from the tokens source on demand. In other words, until you ask for a&#10;   token using consume(), LT(), etc. the stream does not pull from the lexer.&#10; &#10;   The only difference between this stream and BufferedTokenStream superclass&#10;   is that this stream knows how to ignore off channel tokens. There may be&#10;   a performance advantage to using the superclass if you don't pass&#10;   whitespace and comments etc. to the parser on a hidden channel (i.e.,&#10;   you set channel instead of calling skip() in lexer rules.)" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="747" />
        <entry key="ENGLISH" value="748" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1668074231743" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>