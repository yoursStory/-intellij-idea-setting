<application>
  <component name="AppStorage">
    <histories>
      <item value="on Miss Default Value" />
      <item value="字典" />
      <item value="Complex Transformer Proxy" />
      <item value="  Like the assembly:attached goal, assemble an application bundle or&#10;  distribution using an assembly descriptor from the command line. This goal&#10;  will force Maven to build all included POMs up to the package phase BEFORE the&#10;  assembly is processed. This goal differs from assembly:assembly in that it&#10;  ignores the &lt;formats&gt; section of the assembly descriptor, and forces the&#10;  assembly to be created as a directory in the project's build-output directory&#10;  (usually .target).&#10;  This goal is also functionally equivalent to using the assembly:assembly goal&#10;  in conjunction with the dir assembly format.&#10;  NOTE: This goal should ONLY be run from the command line, and if building a&#10;  multimodule project it should be used from the root POM. Use the&#10;  assembly:directory-single goal for binding your assembly to the lifecycle." />
      <item value="Assemble an application bundle or distribution using an assembly descriptor&#10;  from the command line. This goal will force Maven to build all included POMs&#10;  up to the package phase BEFORE the assembly is processed.&#10;  NOTE: This goal should ONLY be run from the command line, and if building a&#10;  multimodule project it should be used from the root POM. Use the&#10;  assembly:single goal for binding your assembly to the lifecycle." />
      <item value="assembly" />
      <item value="asse" />
      <item value="firewall-cmd --add-port=123/tcp --permanent" />
      <item value="asset Manage CK Info" />
      <item value="  Simple stop watch, allowing for timing of a number of tasks, exposing total&#10;  running time and running time for each named task.&#10; &#10;  &lt;p&gt;Conceals use of {@link SystemnanoTime()}, improving the readability of&#10;  application code and reducing the likelihood of calculation errors.&#10; &#10;  &lt;p&gt;Note that this object is not designed to be thread-safe and does not use&#10;  synchronization.&#10; &#10;  &lt;p&gt;This class is normally used to verify performance during proof-of-concept&#10;  work and in development, rather than as part of production applications.&#10; &#10;  &lt;p&gt;As of Spring Framework 5.2, running time is tracked and reported in" />
      <item value="escalation" />
      <item value="scenario Analysis Report" />
      <item value="demand" />
      <item value="      Returns the trigonometric cosine of an angle. Special cases:&#10;      &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the&#10;      result is NaN.&lt;ul&gt;&#10;     &#10;      &lt;p&gt;The computed result must be within 1 ulp of the exact result.&#10;      Results must be semi-monotonic." />
      <item value="  Instances of this class support both reading and writing to a&#10;  random access file. A random access file behaves like a large&#10;  array of bytes stored in the file system. There is a kind of cursor,&#10;  or index into the implied array, called the &lt;em&gt;file pointer&lt;em&gt;;&#10;  input operations read bytes starting at the file pointer and advance&#10;  the file pointer past the bytes read. If the random access file is&#10;  created in readwrite mode, then output operations are also available;&#10;  output operations write bytes starting at the file pointer and advance&#10;  the file pointer past the bytes written. Output operations that write&#10;  past the current end of the implied array cause the array to be&#10;  extended. The file pointer can be read by the&#10;  {@code getFilePointer} method and set by the {@code seek}&#10;  method.&#10;  &lt;p&gt;&#10;  It is generally true of all the reading routines in this class that&#10;  if end-of-file is reached before the desired number of bytes has been&#10;  read, an {@code EOFException} (which is a kind of&#10;  {@code IOException}) is thrown. If any byte cannot be read for&#10;  any reason other than end-of-file, an {@code IOException} other&#10;  than {@code EOFException} is thrown. In particular, an&#10;  {@code IOException} may be thrown if the stream has been closed." />
      <item value="Reads in &lt;b&gt;little endian&lt;b&gt; order, as required by the zipfile&#10;  format." />
      <item value="max Fill Read Capacity" />
      <item value="      Waits at most {@code millis} milliseconds for this thread to&#10;      die. A timeout of {@code 0} means to wait forever.&#10;     &#10;      &lt;p&gt; This implementation uses a loop of {@code this.wait} calls&#10;      conditioned on {@code this.isAlive}. As a thread terminates the&#10;      {@code this.notifyAll} method is invoked. It is recommended that&#10;      applications not use {@code wait}, {@code notify}, or&#10;      {@code notifyAll} on {@code Thread} instances." />
      <item value="Method called to assign value serializer for property" />
      <item value=" * Abstract class that defines API for objects that can be registered (for {@link BeanSerializerFactory}&#10; * to participate in constructing {@link BeanSerializer} instances.&#10; * This is typically done by modules that want alter some aspects of serialization&#10; * process; and is preferable to sub-classing of {@link BeanSerializerFactory}.&#10; *&lt;p&gt;&#10; * Sequence in which callback methods are called is as follows:&#10; * &lt;ol&gt;&#10; *  &lt;li&gt;After factory has collected tentative set of properties (instances of&#10; *     &lt;code&gt;BeanPropertyWriter&lt;/code&gt;) is sent for modification via&#10; *     {@link #changeProperties}. Changes can include removal, addition and&#10; *     replacement of suggested properties.&#10; *  &lt;li&gt;Resulting set of properties are ordered (sorted) by factory, as per&#10; *     configuration, and then {@link #orderProperties} is called to allow&#10; *     modifiers to alter ordering.&#10; *  &lt;li&gt;After all bean properties and related information is accumulated,&#10; *     {@link #updateBuilder} is called with builder, to allow builder state&#10; *     to be modified (including possibly replacing builder itself if necessary)&#10; *  &lt;li&gt;Once all bean information has been determined,&#10; *     factory creates default {@link BeanSerializer} instance and passes&#10; *     it to modifiers using {@link #modifySerializer}, for possible&#10; *     modification or replacement (by any {@link com.fasterxml.jackson.databind.JsonSerializer} instance)&#10; * &lt;/ol&gt;&#10; *&lt;p&gt;&#10; * Default method implementations are &quot;no-op&quot;s, meaning that methods are implemented&#10; * but have no effect." />
      <item value="Intrinsic Candidate" />
      <item value="is Assignable From" />
      <item value="  * Determines if the class or interface represented by this&#10;     * {@code Class} object is either the same as, or is a superclass or&#10;     * superinterface of, the class or interface represented by the specified&#10;     * {@code Class} parameter. It returns {@code true} if so;&#10;     * otherwise it returns {@code false}. If this {@code Class}&#10;     * object represents a primitive type, this method returns&#10;     * {@code true} if the specified {@code Class} parameter is&#10;     * exactly this {@code Class} object; otherwise it returns&#10;     * {@code false}.&#10;     *&#10;     * &lt;p&gt; Specifically, this method tests whether the type represented by the&#10;     * specified {@code Class} parameter can be converted to the type&#10;     * represented by this {@code Class} object via an identity conversion&#10;     * or via a widening reference conversion. See &lt;cite&gt;The Java Language&#10;     * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},&#10;     * for details." />
      <item value="structured" />
      <item value="compared" />
      <item value=" * Vanilla {@link com.fasterxml.jackson.databind.Module} implementation that allows registration&#10; * of serializers and deserializers, bean serializer&#10; * and deserializer modifiers, registration of subtypes and mix-ins&#10; * as well as some other commonly&#10; * needed aspects (addition of custom {@link AbstractTypeResolver}s,&#10; * {@link com.fasterxml.jackson.databind.deser.ValueInstantiator}s).&#10; *&lt;p&gt;&#10; * NOTE: although it is not expected that sub-types should need to&#10; * override {@link #setupModule(SetupContext)} method, if they choose&#10; * to do so they MUST call {@code super.setupModule(context);}&#10; * to ensure that registration works as expected.&#10; *&lt;p&gt;&#10; * WARNING: when registering {@link JsonSerializer}s and {@link JsonDeserializer}s,&#10; * only type erased {@code Class} is compared: this means that usually you should&#10; * NOT use this implementation for registering structured types such as&#10; * {@link java.util.Collection}s or {@link java.util.Map}s: this because parametric&#10; * type information will not be considered and you may end up having &quot;wrong&quot; handler&#10; * for your type.&#10; * What you need to do, instead, is to implement {@link com.fasterxml.jackson.databind.deser.Deserializers} &#10; * and/or {@link com.fasterxml.jackson.databind.ser.Serializers} callbacks to match full type&#10; * signatures (with {@link JavaType})." />
      <item value="create Contextual" />
      <item value=" * Add-on interface that {@link JsonSerializer}s can implement to get a callback&#10; * that can be used to create contextual instances of serializer to use for&#10; * handling properties of supported type. This can be useful&#10; * for serializers that can be configured by annotations, or should otherwise&#10; * have differing behavior depending on what kind of property is being serialized.&#10; *&lt;p&gt;&#10; * Note that in cases where serializer needs both contextualization and&#10; * resolution -- that is, implements both this interface and {@link ResolvableSerializer}&#10; * -- resolution via {@link ResolvableSerializer} occurs first, and contextual&#10; * resolution (via this interface) later on." />
      <item value="     * Method called to see if a different (or differently configured) serializer&#10;     * is needed to serialize values of specified property.&#10;     * Note that instance that this method is called on is typically shared one and&#10;     * as a result method should &lt;b&gt;NOT&lt;/b&gt; modify this instance but rather construct&#10;     * and return a new instance. This instance should only be returned as-is, in case&#10;     * it is already suitable for use.&#10;     * &#10;     * @param prov Serializer provider to use for accessing config, other serializers&#10;     * @param property Method or field that represents the property&#10;     *   (and is used to access value to serialize).&#10;     *   Should be available; but there may be cases where caller cannot provide it and&#10;     *   null is passed instead (in which case impls usually pass 'this' serializer as is)&#10;     * &#10;     * @return Serializer to use for serializing values of specified property;&#10;     *   may be this instance or a new instance." />
      <item value="Desensitize" />
      <item value="Phone Desensitize" />
      <item value="desensitization" />
      <item value="validate If Applicable" />
      <item value="determine Group Validation Order" />
      <item value="process Constraint Violations" />
      <item value="Violation Field Error" />
      <item value="intern" />
      <item value="interned" />
      <item value="     * Returns a canonical representation for the string object.&#10;     * &lt;p&gt;&#10;     * A pool of strings, initially empty, is maintained privately by the&#10;     * class {@code String}.&#10;     * &lt;p&gt;&#10;     * When the intern method is invoked, if the pool already contains a&#10;     * string equal to this {@code String} object as determined by&#10;     * the {@link #equals(Object)} method, then the string from the pool is&#10;     * returned. Otherwise, this {@code String} object is added to the&#10;     * pool and a reference to this {@code String} object is returned.&#10;     * &lt;p&gt;&#10;     * It follows that for any two strings {@code s} and {@code t},&#10;     * {@code s.intern() == t.intern()} is {@code true}&#10;     * if and only if {@code s.equals(t)} is {@code true}.&#10;     * &lt;p&gt;&#10;     * All literal strings and string-valued constant expressions are&#10;     * interned. String literals are defined in section 3.10.5 of the&#10;     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.&#10;     *&#10;     * @return  a string that has the same contents as this string, but is&#10;     *          guaranteed to be from a pool of unique strings." />
      <item value="is Eligible For Overriding" />
      <item value="     * Returns a set backed by the specified map.  The resulting set displays&#10;     * the same ordering, concurrency, and performance characteristics as the&#10;     * backing map.  In essence, this factory method provides a {@link Set}&#10;     * implementation corresponding to any {@link Map} implementation.  There&#10;     * is no need to use this method on a {@link Map} implementation that&#10;     * already has a corresponding {@link Set} implementation (such as {@link&#10;     * HashMap} or {@link TreeMap}).&#10;     *&#10;     * &lt;p&gt;Each method invocation on the set returned by this method results in&#10;     * exactly one method invocation on the backing map or its &lt;tt&gt;keySet&lt;/tt&gt;&#10;     * view, with one exception.  The &lt;tt&gt;addAll&lt;/tt&gt; method is implemented&#10;     * as a sequence of &lt;tt&gt;put&lt;/tt&gt; invocations on the backing map.&#10;     *&#10;     * &lt;p&gt;The specified map must be empty at the time this method is invoked,&#10;     * and should not be accessed directly after this method returns.  These&#10;     * conditions are ensured if the map is created empty, passed directly&#10;     * to this method, and no reference to the map is retained, as illustrated&#10;     * in the following code fragment:&#10;     * &lt;pre&gt;" />
      <item value="     * Returns a set backed by the specified map.  The resulting set displays&#10;     * the same ordering, concurrency, and performance characteristics as the&#10;     * backing map.  In essence, this factory method provides a {@link Set}&#10;     * implementation corresponding to any {@link Map} implementation.  There&#10;     * is no need to use this method on a {@link Map} implementation that&#10;     * already has a corresponding {@link Set} implementation (such as {@link&#10;     * HashMap} or {@link TreeMap}).&#10;     *&#10;     * &lt;p&gt;Each method invocation on the set returned by this method results in&#10;     * exactly one method invocation on the backing map or its &lt;tt&gt;keySet&lt;/tt&gt;&#10;     * view, with one exception.  The &lt;tt&gt;addAll&lt;/tt&gt; method is implemented&#10;     * as a sequence of &lt;tt&gt;put&lt;/tt&gt; invocations on the backing map.&#10;     *&#10;     * &lt;p&gt;The specified map must be empty at the time this method is invoked,&#10;     * and should not be accessed directly after this method returns.  These&#10;     * conditions are ensured if the map is created empty, passed directly&#10;     * to this method, and no reference to the map is retained, as illustrated&#10;     * in the following code fragment:&#10;     * &lt;pre&gt;&#10;     *    Set&amp;lt;Object&amp;gt; weakHashSet = Collections.newSetFromMap(&#10;     *        new WeakHashMap&amp;lt;Object, Boolean&amp;gt;());&#10;     * &lt;/pre&gt;" />
      <item value="override Delegate" />
      <item value="     * Registers the caller as parallel capable.&#10;     * The registration succeeds if and only if all of the following&#10;     * conditions are met:&#10;     * &lt;ol&gt;&#10;     * &lt;li&gt; no instance of the caller has been created&lt;/li&gt;&#10;     * &lt;li&gt; all of the super classes (except class Object) of the caller are&#10;     * registered as parallel capable&lt;/li&gt;&#10;     * &lt;/ol&gt;&#10;     * &lt;p&gt;Note that once a class loader is registered as parallel capable, there&#10;     * is no way to change it back.&lt;/p&gt;&#10;     *&#10;     * @return  true if the caller is successfully registered as&#10;     *          parallel capable and false if otherwise." />
      <item value=" * {@code ClassLoader} that does &lt;i&gt;not&lt;/i&gt; always delegate to the parent loader&#10; * as normal class loaders do. This enables, for example, instrumentation to be&#10; * forced in the overriding ClassLoader, or a &quot;throwaway&quot; class loading behavior&#10; * where selected application classes are temporarily loaded in the overriding&#10; * {@code ClassLoader} for introspection purposes before eventually loading an&#10; * instrumented version of the class in the given parent {@code ClassLoader}.&#10; *" />
      <item value="subtype" />
      <item value="Caller Sensitive" />
      <item value="     * Returns the context ClassLoader for this Thread. The context&#10;     * ClassLoader is provided by the creator of the thread for use&#10;     * by code running in this thread when loading classes and resources.&#10;     * If not {@linkplain #setContextClassLoader set}, the default is the&#10;     * ClassLoader context of the parent Thread. The context ClassLoader of the&#10;     * primordial thread is typically set to the class loader used to load the&#10;     * application.&#10;     *&#10;     * &lt;p&gt;If a security manager is present, and the invoker's class loader is not&#10;     * {@code null} and is not the same as or an ancestor of the context class&#10;     * loader, then this method invokes the security manager's {@link&#10;     * SecurityManager#checkPermission(java.security.Permission) checkPermission}&#10;     * method with a {@link RuntimePermission RuntimePermission}{@code&#10;     * (&quot;getClassLoader&quot;)} permission to verify that retrieval of the context&#10;     * class loader is permitted." />
      <item value="&#10; * &lt;p&gt; If a particular concrete provider class is named in more than one&#10; * configuration file, or is named in the same configuration file more than&#10; * once, then the duplicates are ignored.  The configuration file naming a&#10; * particular provider need not be in the same jar file or other distribution&#10; * unit as the provider itself.  The provider must be accessible from the same&#10; * class loader that was initially queried to locate the configuration file;&#10; * note that this is not necessarily the class loader from which the file was&#10; * actually loaded.&#10; *&#10; * &lt;p&gt; Providers are located and instantiated lazily, that is, on demand.  A&#10; * service loader maintains a cache of the providers that have been loaded so&#10; * far.  Each invocation of the {@link #iterator iterator} method returns an&#10; * iterator that first yields all of the elements of the cache, in&#10; * instantiation order, and then lazily locates and instantiates any remaining&#10; * providers, adding each one to the cache in turn.  The cache can be cleared&#10; * via the {@link #reload reload} method.&#10; *&#10; * &lt;p&gt; Service loaders always execute in the security context of the caller.&#10; * Trusted system code should typically invoke the methods in this class, and&#10; * the methods of the iterators which they return, from within a privileged&#10; * security context.&#10; *&#10; * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent&#10; * threads." />
      <item value=" A simple service-provider loading facility.&#10; *&#10; * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known set of interfaces and (usually&#10; * abstract) classes.  A &lt;i&gt;service provider&lt;/i&gt; is a specific implementation&#10; * of a service.  The classes in a provider typically implement the interfaces&#10; * and subclass the classes defined in the service itself.  Service providers&#10; * can be installed in an implementation of the Java platform in the form of&#10; * extensions, that is, jar files placed into any of the usual extension&#10; * directories.  Providers can also be made available by adding them to the&#10; * application's class path or by some other platform-specific means.&#10; *&#10; * &lt;p&gt; For the purpose of loading, a service is represented by a single type,&#10; * that is, a single interface or abstract class.  (A concrete class can be&#10; * used, but this is not recommended.)  A provider of a given service contains&#10; * one or more concrete classes that extend this &lt;i&gt;service type&lt;/i&gt; with data&#10; * and code specific to the provider.  The &lt;i&gt;provider class&lt;/i&gt; is typically&#10; * not the entire provider itself but rather a proxy which contains enough&#10; * information to decide whether the provider is able to satisfy a particular&#10; * request together with code that can create the actual provider on demand.&#10; * The details of provider classes tend to be highly service-specific; no&#10; * single class or interface could possibly unify them, so no such type is&#10; * defined here.  The only requirement enforced by this facility is that&#10; * provider classes must have a zero-argument constructor so that they can be&#10; * instantiated during loading." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="662" />
        <entry key="ENGLISH" value="652" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="7" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1660817696460" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Cambria" />
    <option name="primaryFontFamily" value="DialogInput" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="512e876ddd7d2c77" />
      </youdao-translate>
    </option>
  </component>
</application>